---
title: "Module 4 : Service web & clients"
description: "Cr√©ation de services web, de RESTful API & requ√™tes clientes"
---

# Module 4 : Service web & clients
Ce module vous offre principalement la cr√©ation de services web et la mise en place de 
requ√™tes clientes pour tester des RESTful API.

Voici les sujets trait√©s :
- a) [Introduction au backend](#a)
- b) [Introduction √† Node.js](#b)
  - b.1) [Introduction](#b1)
  - b.2) [Ou mettre du code Node.js ?](#b2)
  - b.3) [Les modules CommonJS](#b3)
  - b.4) [Introduction aux packages](#b4)
- c) [Introduction √† Express](#c)
  - c.1) [Introduction](#c1)
  - c.2) [Cr√©er une application Express "from scratch"](#c2)
  - c.3) [Cr√©er une application Express via un g√©n√©rateur](#c3)
- d) [Introduction aux RESTful API](#d)
  - d.1) [Introduction](#d1)
  - d.2) [Conventions REST](#d2)
- e) [RESTful API via Express](#e)
  - e.1) [Intro](#e1)
  - e.2) [](#e2)
  - e.3) [](#e3)

# <a id="a"></a>a) Introduction au backend
## a.1) Frontend, backend, c'est quoi ?
Un **frontend**, c'est une application :
- qui s'ex√©cute c√¥t√© client, une IHM, qu'on pourrait aussi appeler UI ;
- qui est en direct interaction avc l'utilisateur ;
- impl√©ment√©, dans ce cours-ci, en HTML / CSS / JS.

Un **backend**, c'est une application :
- qui s'ex√©cute c√¥t√© serveur ; 
- qui n'offre pas d'interaction directe avec l'utilisateur ;
- qui parfois met √† disposition le **frontend** ;
- qui parfois offre des op√©rations sur des donn√©es.

## a.2) R√¥les principaux du backend
### a.2.1) Fourniture du frontend
Un des r√¥les du backend est de fournir le frontend :
- **via un serveur de fichiers statiques** ; c'est la mise √† disposition des assets : fichiers HTML,
CSS, JS, images...
- **via la g√©n√©ration dynamique de pages HTML** ; c'est ce qui se passe quand le backend 
fait du Server Side Rendering (SSR), g√©n√©ralement dans le cadre de Multi Page Applications.  

Dans le cadre de ce cours, nous ne ferons pas de g√©n√©ration dynamique d'HTML c√¥t√© serveur (ou SSR).  
Par contre, nous avons d√©j√† vu :
- comment faire de la g√©n√©ration dynamique d'HTML c√¥t√© client (ou 
Client Side Rendering = CSR).
- mettre √† disposition notre frontend, notre IHM, √† l'aide d'un serveur de fichiers statiques : 
c'est ce que notamment fait le serveur de d√©veloppement de Webpack, il me √† disposition les assets 
permettant au browser d'ex√©cuter l'application web.

### a.2.2) Fourniture d'op√©rations sur des ressources
Un autre r√¥le important du backend est de mettre √† disposition des op√©rations sur des ressources,
c'est ce qu'on appelle les services web ou web API.

Il existe diff√©rents types de technologies et architectures web permettant d'impl√©menter 
des web services, notamment :
- **RESTful API** ; c'est l'architecture qui actuellement est la plus utilis√©e et qui sera apprise dans 
le cadre de ce cours.
- **GraphQL API** ; c'est une technologie r√©cente qui permet de tr√®s rapidement cr√©er des requ√™tes 
sur des ressources et qui a √©t√© cr√©√©e par Facebook ; nous ne verrons pas cette technologie dans 
le cadre de ce cours.
- **SOAP API** ; c'est une fa√ßon ancienne de cr√©er des op√©rations sur des ressources mettant en 
oeuvre de l'XML pour communiquer entre des applications clients / serveurs. Nous ne verrons 
pas cette technologie dans le cadre de ce cours.

### a.2.3) Autres r√¥les du backend ?
Un backend peut offrir d'autres services, comme :
- **proxy** : interm√©diaire entre les clients demandant une ressource et le serveur fournissant 
cette ressource. On verra ce type de service, notamment pour masquer l'origine d'une requ√™te √† 
une API.
- **reverse proxy** : c'est un serveur qui fait l'interm√©diaire avec d'autres serveurs, cachant 
au client qui est le v√©ritable serveur ayant trait√© de sa requ√™te. Par exemple, un proxy serveur 
peut mettre √† disposition des acc√®s √† des serveurs interne √† une entreprise (non visibles sur le web)
alors que le client interroge un serveur qui est visible sur le web.
- **serveur d'emails** ;
- ...

### a.2.3) Technologies backend possibles

Voici un exemple de technologies qui pourrait √™tre mises en oeuvre pour d√©velopper une application
backend :

<ScrollableImage name="techno.png" minWidth="586px" maxWidth="586px" />

  <figcaption>Technologies backend possibles</figcaption>

### a.2.4) Technologies backend s√©lectionn√©es pour ce cours

Voici les technologies qui ont √©t√© choisies pour √™tre mises en oeuvre 
pour d√©velopper une application backend en JS :

<ScrollableImage name="techno-course.png" minWidth="721px" maxWidth="721px" />

  <figcaption>Technologies backend en JS choisies pour ce cours</figcaption>

Nous allons utiliser Express comme framework pour rapidement d√©velopper des applications Node.js.

# <a id="b"></a>b) Introduction √† Node.js
## <a id="b1"></a> b.1) Introduction
Node.js est un environnement serveur open source permettant la cr√©ation d'outils 
et applications c√¥t√© serveur en JS.  
Node.js offre une utilisation optimale des ressources des serveurs sans d√©pendance 
√† un serveur http externe, tout en √©tant multiplateforme (Windows, Linux, Mac‚Ä¶).

Pour le d√©veloppement d'IHM de fa√ßon modernes, vous avez d√©j√† install√© l'environnement
Node.js. Mais si √ßa n'est pas install√©, il est important que vous installiez l'environnement 
[Node.js en version LTS](https://nodejs.org/en/) [[R.34]](/references/#r34).

Vous ne devez pas apprendre un nouveau langage pour d√©velopper des applications backend, 
Node.js, c'est du JS.  
Si vous avez besoin d'un rappel du langage, vous pouvez le faire ici : [Introduction au langage JS](/intro/#e).

Tr√®s souvent, Node.js est cod√© en JS conforme au standard CommonJS.
La gestion des modules est diff√©rente du JS conforme au standard ECMAScript, telle que nous avons
appris pour du JS c√¥t√© browser.

M√™me s'il est possible d'√©crire du Node.js conforme au standard ECMAScript, la majorit√© du code 
que vous trouverez sur le web sera conforme √† CommonJS.

D√®s lors, nous allons vous expliquer plus tard comment g√©rer des modules en Node.js conforme au 
standard CommonJS.

## <a id="b2"></a> b.2) Ou mettre du code Node.js ?
### b.2.1) Directement dans un terminal
Il est possible d'√©crire du code Node.js directement dans un terminal.

Pour rappel, nous vous conseillons d'utiliser Git Bash comme terminal au sein de VS Code. 

Vous devriez d√©j√† avoir configur√© VS Code pour avoir comme Terminal par d√©faut 
Git Bash. Si √ßa n'est pas fait, nous vous rappelons la proc√©dure :
- Vous devez avoir install√© Git sur votre machine.
- Clicquez √† droite du **+** au sein d'un terminal ouvert dans VS Code, 
clic sur **Select Default Profile**, puis s√©lectionnez "Git Bash".
Tous les prochains terminaux que vous ouvrirez le seront sous Git Bash, nettement plus color√© 
et int√©ressant que les autres terminaux üòé.

<ScrollableImage name="terminal-2.png" minWidth="933px" maxWidth="933px" />

<figcaption>Choix du terminal par d√©faut</figcaption>

Veuillez tester du code Node.js directement dans un terminal en tapant 
cela au sein d'un terminal de VS Code :

```bash
node
```

Vous avez maintenant acc√®s au terminal de Node.js.  
Vous pouvez tenter une op√©ration math√©matique de votre choix, comme par exemple :
**2 * Math.PI**

Incroyable mais vrai, vous avez maintenant acc√®s √† une nouvelle calculatrice sur tous les appareils 
o√π vous avez Node.js install√©. Et si Node.js n'est pas install√©, pas de panique, 
la console de votre Browser pourra toujours vous aider üòâ.

Quand vous souhaitez sortir de l'interpr√©teur de commandes de Nodes, il faut taper :
- soit deux fois **`CTRL c`**
- soit **`CTRL d`**

### b.2.2) Dans un script
Nous √©crivons g√©n√©ralement le code Node.js au sein d'un script externe.

Dans votre repo **web2**, veuillez cr√©er un r√©pertoire **/tutorials/node-start** et y 
ajouter le fichier **start.js** contenant ce code-ci :

```js
class Car {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
    this.id = Math.random();
  }

  getDescription() {
    return `Car's description : ${this.brand}, ${this.model} , ID:${this.id}`;
  }
}

const dacia = new Car('Dacia', 'Sandero');

console.log( dacia.getDescription() );
```

Pour lancer une application Node.js, il suffit de taper dans un terminal : **`node nomScript`** 
(**`.js`** est optionnel).

Donc pour lancer le script cr√©√© ci-dessus, veuillez ouvrir un terminal au bon endroit.  
Pour rappel, Il est possible de faire un clic droit dans l'Explorer de VS Code 
sur le r√©pertoire **node-start**, **Open in Integrated Terminal** pour ouvrir un terminal 
√† l'endroit souhait√©.

Il ne vous reste plus qu'√† taper :

```bash
node start # or node start.js
```

Voila, c'est une simple application Node.js qui affiche un message dans le terminal.

## <a id="b3"></a> b.3) Les modules CommonJS
### b.3.1) Introduction
Un module est une librairie JS fournissant des objets.
Comme en JS tout est objet, un module met donc √† disposition des fonctions, des constantes, des variables...

### b.3.2) Cr√©ation d'un module
Pour cr√©er un module, il suffit de cr√©er un script JS **nomModule.js** et d'exporter des
objets au sein de ce module via **module.exports** ou **exports**.

### b.3.3) Exporter des objets
#### b.3.3.1) Introduction
Il existe plusieurs fa√ßons d'exporter des objets, soit √† la vol√©e, soit √† la fin d'un script.

üëç Nous vous recommandons de faire vos exports √† la fin du script, cela rend les scripts plus 
lisibles. 

Nous allons n√©anmoins voir toutes les fa√ßons d'exporter des objets en CommonJS, car vous trouverez
de tout sur le web.

On exporte toujours un seul objet principal dans un module. Cet objet peut bien s√ªr contenir 
une multitude d'objets via ses propri√©t√©s.

#### b.3.3.2) Export √† la fin d'un script
C'est la fa√ßon la plus propre d'exporter un seul objet :

```js
module.exports¬†=¬†router;
```

C'est l'√©quivalent d'un "default export" tel que vu en ECMAScript.

S'il y a plusieurs objets √† exporter, voici la fa√ßon recommand√©e de le faire : 

```js
module.exports¬†=¬†{authorize,¬†users¬†};
```

C'est l'√©quivalent d'un "Named export" tel que vu en ECMAScript.

#### b.3.3.3) Export √† la vol√©e

Il est possible de faire des exports √† la vol√©e, c'est √† dire d'exporter des objets 
au fur et √† mesure qu'ils sont initialis√©s.

Voici la version longue :

```js
module.exports.authorize¬†=¬†authorize;
module.exports.users¬†=¬†users¬†;
```

Il est aussi possible d'√©courter une export √† la vol√©e : 
```js
exports.authorize¬†=¬†authorize;
exports.users¬†=¬†users¬†;
```

Voici quelques pr√©cisions :
- **`module.exports`** : c'est la r√©f√©rence de l'objet retourn√©e par l'appel de **`required()`** 
(m√©thode qui sera utilis√©e pour l'import).
- **`exports`** : c'est la r√©f√©rence vers **`module.exports`**, **`exports`** 
n'est pas retourn√© par l'appel de **`required()`**.

‚ö° Il faut faire attention au mauvais usage de l'utilisation de **`exports`**. 
Voici une mauvaise utilisation :

```js
exports¬†=¬†{¬†authorize,¬†users¬†};¬†/*¬†exports¬†has¬†a¬†new¬†reference,¬†
                                   it¬†is¬†no¬†longer¬†linked¬†to¬†module.exports */
```

### b.3.4) Importer des objets
#### b.3.4.1) Introduction
Pour utiliser des objets (fonctions, constantes, objets, classes...) au sein d'un script JS 
provenant de modules, on le fait √† l'aide de la fonction **`required()`** et du 
chemin vers le module √† utiliser.

Il est possible d'importer tant des objets de modules que l'on a cr√©√© soi-m√™me, 
que de packages mis √† disposition via un gestionnaire de packages.

#### b.3.4.2) Import d'un module
Lorsqu'un seul objet a √©t√© export√©, on l'importe en lui donnant le nom que l'on souhaite 
√† l'import et en indiquant le chemin vers le module √† utiliser.

```js
const¬†pizzaRouter¬†=¬†require('./routes/pizzas');
```

Lorsque plusieurs objets ont √©t√© export√©s, on importe ce que l'on souhaite en utilisant 
des accolades et en indiquant le chemin vers le module √† utiliser.

```js
const¬†{¬†users,¬†authorize¬†}¬†=¬†require('../utils/auths');
```

#### b.3.4.2) Import d'un package
Il est aussi possible d'importer des objets de packages offerts par la 
communaut√© via votre gestionnaire de package.
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import.

Si un seul objet est export√© par un package, voici un exemple de comment le r√©cup√©rer :

```js
//¬†module¬†integrated¬†to¬†the¬†runtime¬†environment
const¬†http¬†=¬†require('http');
//¬†module¬†following package installation
const¬†shortid¬†=¬†require('shortid');
```

## <a id="b4"></a> b.4) Introduction aux packages
### b.4.1) Introduction
Dans le cadre du d√©veloppement d'IHM modernes, au module 2, nous avons d√©couvert le gestionnaire 
de packages de Node.js. Nous allons r√©sumer les concepts importants ci-dessous.

### b.4.2) Gestionnaire de packages
**npm** est le gestionnaire de packages de Node.js. 

On peut faire des recherches de packages qui serait utiles √† nos application web 
sur [npmjs.com](https://www.npmjs.com/) [[R.48]](/references/#r48).

### b.4.3) Fichier de configuration d'un projet
Tous les packages associ√©s √† une app, ses d√©pendances, sont donn√©es dans le fichier :
**package.json**.

C'est le fichier qui d√©crit la configuration d'un projet JS.

On peut manuellement cr√©er ce fichier √† l'aide de la commande **`npm init`** 
si l'on souhaite quelque chose de plus interactif
ou **`npm init -y`** si l'on souhaite un fichier avec le minimum autog√©n√©r√©.

Voici un exemple de fichier **package.json** :

```json
{
  "name": "api2",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },
  "nodemonConfig": {
    "ignore": [
      "data/*"
    ],
    "exec": "npm run lint && node"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "morgan": "~1.9.1"
  },
  "devDependencies": {
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "nodemon": "^2.0.19",
    "prettier-airbnb-config": "^1.0.0"
  },
  "author": "e-Baron"
}
```

Lors de l'installation d'un package, 
celui-ci s'ajoute √† la liste des d√©pendances.  
Ainsi, si des d√©veloppeurs trouvent votre projet sur Git,
ils n'auront qu'√† ex√©cuter **`npm i`** afin d'installer toutes les d√©pendances.

C'est dans le r√©pertoire **node_modules** que toutes les d√©pendances seront install√©es. 
Ces d√©pendances peuvent √™tre tr√®s volumineuses. C'est donc important de ne jamais 
mettre ce dossier sur vos web repository, via Git.  
Pour ce faire, n'oubliez pas d'inclure un fichier **.gitignore** dans vos repos 
pour ignore **node_modules**.

**package.json** indique les scripts de d√©marrage, 
en fonction de la fa√ßon dont nous souhaitons d√©marrer l'application.

```json
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },  
```

Au regard de cette configuration, on peut d√©marrer l'application √† l'aide de **`npm start`**
ou **`npm run start`**, 
ce qui ex√©cutera le script **`./bin/www`** √† l'aide de **node**.  
On pourrait aussi d√©marer l'application √† l'aide de **`npm run dev`**, ce qui d√©marrerait l'application 
√† l'aide de **nodemon**, un outil permettant de monitorer les changements de fichiers et de 
red√©marrer automatiquement le serveur en cas de changement.

NB : nous verrons plus tard cet outil **nodemon** pour simplifier le d√©veloppement.

### b.4.4) Installer un package
Pour installer un package (ou une d√©pendance), 
il suffit de faire : **`npm i nomDuPackage`** ou **`npm install nomDuPackage`**.

### b.4.5) D√©pendances install√©es
On a vu que **`npm i`** permet d'installer toutes les d√©pendances se trouvant dans 
**package.json**, ainsi que toutes les d√©pendances de ces d√©pendances...

L'arbre exact des d√©pendances install√©es, num√©ro de version..., se trouve dans 
**package-lock.json**. Ce fichier est g√©n√©r√© automatiquement pour chaque op√©ration
modifiant **node_modules** ou **package.json**.

‚ö° Si un fichier **package-lock.json** est compris dans un repo, lorsque vous introduirez 
**`npm i`** pour installer toutes les d√©pendances, npm installera les m√™mes versions que celles 
se trouvant dans **package-lock.json**. Cela peut poser des probl√®mes si votre environnement 
Node.js est en version diff√©rente. En cas de souci, pensez √† effacer le r√©pertoire **node_modules** 
et le fichier **package-lock.json** avant de relancer l'installation de toutes les d√©pendances.

### b.4.6) Localisation d'un module ou package par Node
Node va chercher dans tous les chemins sp√©cifi√©s dans **module.paths** : **node_modules**, **.**...
lorsque **`required()`** est appel√©.

### b.4.7) Mise √† jour des packages vers leur derni√®re version
La mise √† jour de toutes les d√©pendances peut parfois amener √† des gros soucis.

Vous pouvez tenter de mettre √† jour tous vos package en suivant la documentation de Node.js :
[Update all the Node.js dependencies to their latest version](https://nodejs.dev/learn/update-all-the-nodejs-dependencies-to-their-latest-version)
[[R.49]](/references/#r49)

Mais attention, certains packages parfois subissent des "breaking changes", 
ce qui impose que vous deviez faire migrer votre code avant que celui-ci soit fonctionnel.

Nous vous recommandons donc, si vous rencontrer un probl√®me lors de la mise √† jour de tous vos 
packages d'un coup, de revenir √† la situation initiale, et de faire l'upgrade de chaque 
package list√© dans **package.json** individuellement.

# <a id="c"></a> c) Introduction √† Express
## <a id="c1"></a>  c.1) Introduction
Voici le moto du framework Express: "Fast, unopinionated, minimalist web framework for Node.js" 
[Express](https://expressjs.com/)
[[R.50]](/references/#r50).

Express est un framework qui permet de rapidement cr√©er des applications en Node.js. 

Il est possible de cr√©er une application Express soit "from scratch", soit √† partir 
d'un boilerplate.

Dans le cadre de ce cours, nous allons plut√¥t utiliser des boilerplates 
pour g√©n√©rer des applications. N√©anmoins, il est int√©ressant de voir comment cr√©er 
une application "from scratch".

## <a id="c2"></a> c.2) Cr√©er une application Express "from scratch"
Il faut d'abord cr√©er un r√©pertoire pour votre application.

Au sein de votre repo **web2**, veuillez cr√©er le r√©pertoire **/tutorials/express-static-file-server**.

Veuillez, via le terminal, entrer dans ce r√©pertoire.

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/tuturials/express-static-file-server**.

Dans ce r√©pertoire, veuillez g√©n√©rer le fichier de configuration du projet (**package.json**) :
**`npm init`**.  
Veuillez r√©pondre aux questions pour configurer le point d'entr√©e de l'application comme √©tant 
le script **index.js**.

Veuillez configurer le script de d√©marrage de votre application en ajoutant cette ligne au sein 
de **package.json** :

```json {2}
  "scripts": {
    "start": "node index.js",
```

Ainsi, notre application pourra d√©marrer √† l'aide de la commande **`npm start`**.

A ce stade-ci, voila √† quoi devrait ressembler votre **package.json** :

```json
{
  "name": "express-static-file-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "yourName",
  "license": "ISC"
}
```

Veuillez installer Express, son package : 

```bash
npm i express
```

Nous allons cr√©er un simple serveur de fichiers statiques √† l'aide du 
middleware **express.static**, afin de servir tous les fichiers qui se trouveront dans 
le r√©pertoire **public**.

Tout d'abord, t√©l√©chargez ce zip : <LinkFile name="public.zip" target="_blank" download>fichiers statiques</LinkFile>.

Veuillez d√©sarchiver ce r√©pertoire dans votre projet afin d'avoir les fichiers statiques 
qui seront partag√©s par votre serveur au sein de **/public**.  
V√©rifiez bien que vous n'avez qu'un seul r√©pertoire **/public** et pas un **/public/public**.

Il ne reste plus qu'√† cr√©er le serveur. Veuillez cr√©er le fichier **/index.js** et y ajouter 
ce code :

```js
const express = require('express');
const app = express();

app.use(express.static('public'));

const PORT = 7777;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

On voit que juste cette ligne permet la mise en place d'un serveur de fichier statique, 
via le middleware **express.static** :

```js
app.use(express.static('public'));
```

Et pour d√©marrer un serveur web qui √©coute sur le port **7777**, ces lignes sont suffisantes :
```js
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Veuillez lancer l'application en tapant cela dans votre terminal au sein du r√©pertoire du projet :

```bash
npm start
```

Pour acc√©der au serveur de fichiers, vous pouvez le faire via un browser : 
[http://localhost:7777](http://localhost:7777)

Si tout se passe bien, vous devriez avoir acc√®s au site de la pizzeria d√©velopp√© au module 1 de 
ce cours.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**express-static-file-server**".

En cas de souci, vous pouvez acc√©der au code de cette d√©mo ici :
[express-static-file-server](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/express-static-file-server/).

## <a id="c3"></a> c.3) Cr√©er une application Express via un g√©n√©rateur
Le g√©n√©rateur d'applications **express-generator** permet de g√©n√©rer le boilerplate 
d'une application Express de base.

A l'aide du g√©n√©rateur d'applications Express, vous allez cr√©er une application Express 
sans "view engine" car nous n'allons pas faire du Server Side Rendering 
dans le cadre de ce cours.

Veuillez ouvrir un terminal au sein de VS Code au niveau du r√©pertoire **/tutorials**.

Ensuite, cr√©ez une application nomm√©e **basic-generated-app** en tapant :

```bash
npx express-generator --no-view basic-generated-app
```

**npx** permet de directement ex√©cuter un package en mode de commandes en installant une copie 
locale et temporaire de ce package (et de ses d√©pendances).

Veuillez installer les d√©pendances de votre app et la d√©marrer :

```bash
cd basic-generated-app
npm i 
npm start
```

Si vous copier / coller le contenu du r√©pertoire **/public** du tutoriel pr√©c√©dent 
dans le r√©pertoire **public** g√©n√©r√©, l'application fournira le m√™me r√©sultat que la pr√©c√©dente, 
mais sur un port diff√©rent : [http://localhost:3000](http://localhost:3000).

Nous allons d√©couvrir en d√©tails ce qui a √©t√© g√©n√©r√© par **express-generator** un peu plus tard.

Actuellement, on remarquera : 
- le point d'entr√©e de l'application est **./bin/www** au regard de **package.json**;
- que **./bin/www** d√©marre un serveur web sur le port **3000** en lui demandant de s'occuper 
de d√©marrer tous les middlewares en lui passant tout ce qui est export√© de **app.js**.
- **app.js** met aussi √† disposition un serveur de fichier statiques servant le contenu du r√©pertoire 
**public**.

Avant d'aller dans les d√©tails d'Express que nous souhaitons utiliser pour d√©velopper des 
services web de type RESTful, nous allons voir ce que nous entendons par RESTful.

# <a id="d"></a> d) Introduction aux RESTful API
## <a id="d1"></a> d.1) Introduction
**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un 
style architectural pour construire des applications web extensibles, o√π les client et serveurs
sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des 
applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte 
d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, elles sont autoportantes.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PUT) repr√©sentant les op√©rations possibles (CRUD, op√©rations de type Create, Read, 
Update ou Delete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; 
les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ;
dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## <a id="d2"></a> d.2) Conventions REST

 Le type d'op√©ration CRUD (Create, Read, Update ou Delete) sur une ressource est d√©fini 
 via la m√©thode http de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PUT (ou PATCH) = Update

Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API 
permettant de g√©rer des films :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | UPDATE ONE : Replacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

Si cette API est h√©berg√©e √† l'URL racine **http://ilovemoovies.org**, alors nous pourrions identifier 
une ressource de type **films** de cette fa√ßons : **http://ilovemoovies.org/films/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : 
**http://ilovemoovies.org/films/10**.

# <a id="e"></a> d) RESTful API via Express
## <a id="e1"></a> e.1) Introduction
Nous avons pr√©c√©demment g√©n√©r√© une application Express √† l'aide du g√©n√©rateur d'applications.

Veuillez avoir devant vous le code de cette application car nous allons d√©couvrir le r√¥le des 
r√©pertoires et fichiers importants g√©n√©r√©s par **express-generator**.

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express,
mais en focalisant sur ceux utiles aux applications REST.

Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, c'est la seule responsabilit√© du d√©velopeur est de 
s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre
√† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

## <a id="e2"></a> e.2) Configuration et d√©marrage d'une application Express
On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, 
est faite au sein de **package.json**.

En fonction de comment est configur√© l'application, on la d√©marrera via **npm start**, 
**npm run dev**...

## <a id="e3"></a> e.3) Serveur web int√©gr√©
Un serveur web int√©gr√© √† nos applications Express est d√©marr√© au sein du fichier **bin/www**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application 
fonctionne sur un port diff√©rent que le port par d√©faut **3000**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme 
Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

## <a id="e4"></a> e.4) Les fonctions middleware en Express
### e.4.1) C'est quoi une fonction middleware ?

Les fonctions middleware s'occupent du traitement des requ√™tes des clients 
et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>

Une fonction du middleware a acc√®s aux objets de la requ√™te et de la r√©ponse et peut m
odifier la requ√™te et la r√©ponse pour ajouter, par exemple, un log, pour autoriser un utilisateur,
pour parser des donn√©es Json vers des objets JS, pour servir des fichiers statiques, pour faire 
un traitement pour une route bien sp√©cifique...

Si une fonction du middleware ne termine pas le cycle de requ√™te-r√©ponse, elle doit appeller 
**`next()`** pour permettre √† d'autres fonctions qui sont dans la queue de pouvoir √™tre ex√©cut√©es.

Voici les √©l√©ments associ√©s √† l'appel d'une fonction middleware :

<ScrollableImage name="middleware-function.png" minWidth="944px" maxWidth="944px" />

<figcaption>Une fonction middleware [R.53]</figcaption>

Il existe diff√©rent types de fonctions middleware ayant diff√©rents cas d'utilisation :
- Application-level middleware : la fonction middleware est li√©e √† l'objet **app** ;
- Router-level middleware : la fonction middleware est li√©e √† un objet de type **express.router()**, 
elle est tr√®s similaire au "application-level middleware" ;
- Error-handling middleware : fonction de gestion des erreurs qui se d√©finit comme les fonctions 
app ou router level middleware, mais qui contient un quatri√®me param√®tre nomm√© **error**.
- Built-in middleware : fonctions middleware mises √† disposition par Express directement :
  - **express.static** : pour servir des assets statiques ;
  - **express.json** : pour parser le body de requ√™tes en JSON vers des objets JS ;
  - **express.urlencoded** : pour parser des requ√™tes dont le body est de type "urlencoded" (type 
  par d√©faut des formulaires) vers des objets JS. 
- Third-party middleware : fonctions mises √† disposition par la communaut√© et installables via 
npm, comme par exemple la fonction middleware **cookieParser**.

Si vous souhaitez approfondir, nous vous conseillons [la documentation d'Express](https://expressjs.com/en/guide/using-middleware.html#middleware.third-party)
[[R.54]](/references/#r54).

La suite fournit quelques exemples de fonctions middleware qui seront plus tard rencontr√©es 
dans notre code ou extraits de [[R.54]](/references/#r54).

### e.4.2) Application-level middleware : exemple
Voici une fonction middleware qui sera ex√©cut√©e √† chaque fois qu'il y a une requ√™te, quelque soit 
le chemin (ou path) associ√© √† la requ√™te :

```js
var¬†express¬†=¬†require('express');
var¬†app¬†=¬†express();
app.use((req,¬†res,¬†next) =>¬†{
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});
```

### e.4.3) Router-level middleware : exemple

```js
var¬†router¬†=¬†express.Router();

router.use((req,¬†res,¬†next)¬†=> {
¬†¬†console.log('Time:'',¬†Date.now());
¬†¬†next();
});

router.get('/',(req,¬†res,¬†next)¬†=> {
¬†¬†return¬†res.json(menu);
});
```

La premi√®re fonction middleware ne contient pas de m√©thode HTTP, ni de chemin, elle s'applique 
donc √† toutes les routes associ√©es au router.

```js
var pizzaRouter = require('./routes/pizzas');
app.use('/pizzas', pizzaRouter);
```

Si le router est utilis√© de cette fa√ßon, la premi√®re fonction s'applique donc √† toutes les routes 
qui commencent par '/pizzas'.

La deuxi√®me fonction middleware s'appliquent seulement aux requ√™tes de type GET sur la route (ou 
le chemin) '/pizzas' (√©quivalent de la route '/pizzas/').

### e.4.4) Error-handling middleware : exemple
Ce type de middleware est √† d√©finir apr√®s tous les middlewares pouvant g√©n√©rer une erreur et 
est appel√© via **`next(err)`** dans une fonction middleware o√π un souci est d√©tect√©.

Voici la d√©finition d'un "error handler" :

```js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
});
```

Attention, il y a bien 4 param√®tres au lieu des 3 habituels pour les autres types de fonctions 
middleware.

### e.4.5) Built-in middleware & third-party middleware : exemple

```js
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var app = express();

app.use(logger('dev')); //¬†HTTP request logger
app.use(express.json()); //¬†Parse requests with JSON payloads
app.use(express.urlencoded({ extended: false })); //¬†Parse requests with URL-
                                                  // encoded payload 
app.use(cookieParser()); //¬†Parse cookie header (req.cookies)
app.use(express.static(path.join(__dirname, 'public'))); //¬†Serve static assets
```

## <a id="e5"></a> e.5) Routing en Express
### e.5.1) D√©finition d'une route
#### e.5.1.1) Concepts
Le "Routing", ou routage, contr√¥le la r√©ponse √† une requ√™te client pour un 
**endpoint** / **URI** / **PATH** et une m√©thode HTTP.

On va d√©finir une route soit sur l'objet **app**, soit sur un **router**.  
Un objet de type **router** permet de regrouper toutes les routes associ√©es √† un type de 
ressources.

On d√©finit une route de cette fa√ßon : **app.** ou **router.**  **METHOD(PATH, MIDDLEWARE_FUNCTION)**.

üëç Dans notre cours, nous vous recommandons d'organiser vos routes par type de ressources et donc 
de mettre en place un router.

#### e.5.1.2) Cr√©ation d'un projet
Nous allons maintenant r√©aliser un tutoriel pour cr√©er notre toute premi√®re RESTful API.
Nous allons cr√©er une API pour permettre √† notre site web de la pizzeria de b√©n√©ficier d'op√©rations 
sur des ressources de type "pizzas".

Dans votre repo **web2**, veuillez cr√©er le r√©pertoire **/tutorials/pizzeria/api**.

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Dans ce r√©pertoire, veuillez g√©n√©rer une application express nomm√©e **basic**. 
Pour ce faire :

```bash
npx express-generator --no-view basic
```

Veuillez installer les d√©pendances :
```bash
cd basic
npm i
```

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/tuturials/pizzeria/hmi/modern** (ou **/web2/tuturials/pizzeria/hmi/modern** si l'on 
consid√®re le nom du r√©pertoire du repo).

Nous allons d√©velopper des RESTful API qui ne poss√®dent pas de serveur de fichiers statiques. 
On n'a donc pas besoin d'avoir un r√©pertoire **/public** ni d'un serveur statique.  
On peut donc effacer le r√©pertoire **/public** et supprimer le middleware 
de serveur de fichiers statiques au sein de **/app.js** : 

```js
app.use(express.static(path.join(__dirname, 'public'))); 
```


#### e.5.1.3) Op√©ration de lecture
Nous souhaitons par commencer √† d√©velopper une op√©ration permettant de lire toutes les ressources 
de type "pizzas". En effet, nous aimerions plus tard que notre IHM re√ßoive de notre API le menu 
des pizzas.

Veuillez cr√©er un router pour traiter des ressources **/pizzas** au sein de **/routes/pizzas.js**.
Le plus simple est d'adapter **indexRouter** dans **app.js** en **pizzaRouter** et **/routers/index.js** 
en **/routes/pizzas.js**.  
Il est aussi possible de partir de rien et de cr√©er **pizzaRouter** dans **app.js** et **/routes/pizzas.js**.

Pour l'op√©ration de lecture de toutes les pizzas, selon les conventions REST, 
il faut faire une requ√™te de type **GET /pizzas**.  
**/routes/pizza.js** doit donc offrir une route renvoyant toutes les pizzas 
qui existent dans le menu.  
Pour d√©marrer, nous souhaitons une application basique qui ne g√®re pas la persistence des donn√©es.
Le menu est donc un Array d'objets, dont chaque objet repr√©sente une pizza.

Notre op√©ration de lecture de pizza va renvoyer du JSON au client, c'est √† dire une repr√©sentation 
textuelle du menu. Nous verrons plus tard ce qu'est r√©ellement le JSON. A ce stade-ci, 
il est suffisant de conna√Ætre la fonction d'Express qui permet √† un objet JS 
de circuler sur le r√©seau : **res.json()**.

Voici le code du router **/routes/pizza.js** :
```js
var express = require('express');
var router = express.Router();

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

// Read all the pizzas from the menu
router.get('/', (req, res, next) => {
  console.log('GET /pizzas');
  res.json(MENU);
});

module.exports = router;
```

Et voici le code de **app.js** (les parties modifi√©es sont surlign√©es) :

```js numbered {6,16}
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var pizzaRouter = require('./routes/pizzas');
var usersRouter = require('./routes/users');

var app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/pizzas', pizzaRouter);
app.use('/users', usersRouter);

module.exports = app;
```

Notons que nous pourrions effacer le router s'occupant des ressources de type "users", mais nous 
pr√©f√©rons le garder car plus tard nous souhaiterons g√©rer l'authentification d'utilisateurs.

Veuillez d√©marrer l'API (par d√©faut elle est configur√©e sur le port 3000 au sein de **bin/www**) :

```bash
npm start
```

Pour consommer l'op√©ration de lecture via un browser, nous pouvons lire toutes les ressources de type "pizzas" ici :
[http://localhost:3000/pizzas](http://localhost:3000/pizzas)

### e.5.2) Chemin et param√®tress de route
Les "route parameters" sont des segments d'une URL qui sont utilis√©s pour capturer une valeur 
sp√©cifi√©e √† leur position dans l'URL. On r√©cup√®re ces param√®tres via l'objet **req.params**.

Pour notre pizzeria, nous souhaitons pouvoir lire une pizza identifi√©e par son **id**.

Nous allons donc ajouter le param√®tre de route **id**. 
En respect des conventions REST, un client, pour faire appel √† cette 
op√©ration, devra faire une requ√™te du genre : **GET /pizzas/2**.

Voici la nouvelle route permettant de traiter de cette op√©ration, √† ajouter dans 
le router **/routes/pizza.js** :
```js
// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const indexOfPizzaFound = MENU.findIndex((pizza) => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.status(404).end();

  res.json(MENU[indexOfPizzaFound]);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire 
la ressource de type "pizzas" identifi√©e par **2** dans le menu ainsi :
[http://localhost:3000/pizzas/2](http://localhost:3000/pizzas/2)

Le browser fait bien une requ√™te du genre : **GET /pizzas/2**.

Le param√®tre de la route "2" est r√©cup√©r√© dans l'URL de la route par 
Express et est offert via **`req.params.id`**. 

N'h√©sitez pas √† faire une requ√™te pour un identifiant n'existant pas de le menu pour voir 
ce qui se passe : 
[http://localhost:3000/pizzas/666](http://localhost:3000/pizzas/666)


### e.5.3) Chemin et param√®tres de requ√™te
Les "query parameters" sont des param√®tres qui peuvent √™tre ajout√©s √† une URL.  
On r√©cup√®re ces param√®tres via l'objet **req.query**.

Pour notre pizzeria, nous souhaitons pouvoir lire toutes les ressources de type 
"pizzas" tri√©es par ordre ascendant ou descendant du titre.

En respect des conventions REST, un client, pour faire appel √† cette 
op√©ration, devra faire une requ√™te du genre : **GET /pizzas?order=title** pour le tri ascendant
ou **GET /pizzas?order=-title** pour le tri descendant .

Il n'y a donc pas de nouvelle route √† ajouter ici. En effet, √ßa reste une requ√™te 
de type GET sur la route "/pizzas". 

Veuillez donc mettre √† jour **/routes/pizza.js** pour la lecture de toutes les pizzas :
```js
/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title') ||
    req?.query?.order?.includes('-title')
      ? req.query.order
      : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);
  if (orderByTitle)
    orderedMenu = MENU.sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  res.json(orderedMenu ?? MENU);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire 
toutes les ressources de type "pizzas" tri√©e par leur titre de mani√®re descendante ainsi :
[http://localhost:3000/pizzas?order=-title](http://localhost:3000/pizzas?order=-title).

N'h√©sitez pas √† tester d'autres tris.