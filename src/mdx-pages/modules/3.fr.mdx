---
title: "Module 3 : IHM structur√©e, routage & animations"
description: "Refactor du code en module, routage des √©crans & base des animations"
---

# Module 3 : IHM structur√©e, routage & animations
Ce module vous offre principalement le refactoring des IHM en modules, le routage des pages ainsi
que les bases pour r√©aliser des animations.

<br/>

Voici les sujets trait√©s :
- a) [Les modules ECMAScript](#a)
  - a.1) [Introduction](#a1)
  - a.2) [Cr√©ation de modules](#a2)
  - a.3) [Exporter des objets](#a3)
  - a.4) [Importer des objets](#a4)
  - a.5) [D√©coupe d'une IHM en modules](#a5)
  - a.6) [Ex√©cution de l'application √† l'aide d'un serveur de d√©veloppement de Webpack](#a6)
- b) [Le routage des √©crans](#b)
  - b.1) [Introduction](#b1)
  - b.2) [Ajout d'une Navbar](#b2)
  - b.3) [Le Layout en Bootstrap](#b3)
  - b.4) [Les breakpoints en Bootstrap](#b4)
  - b.5) [Les composants Bootstrap](#b5)
  - b.6) [Utilisation de Bootstrap dans un frontend moderne](#b6)

Dans cette partie, nous allons voir certaines techniques afin d'am√©liorer la structure 
du code d'une IHM.

# <a id="a"></a> a) Les modules ECMAScript
## <a id="a1"></a> a.1) Introduction
Les modules, selon ECMAScript, sont la norme pour empaqueter du code JS afin d'√™tre r√©utilis√©.

Un module est une librairie JS fournissant des objets.   
Comme en JS tout est objet, un module met donc √† disposition des fonctions, des constantes, des 
variables...

## <a id="a2"></a> a.2) Cr√©ation de modules
Pour cr√©er un module, il suffit de cr√©er un script JS et 
d'exporter des objets au sein de ce module. 

Le nom du module est le nom du fichier.

Admettons que l'on souhaite cr√©er un module permettant de mettre √† disposition une classe **Car**.

Nous pourrions cr√©er le fichier **Car.js** dans lequel nous exportons **Car** de cette fa√ßon :

```js
// ... Imagine the code of a class (we will see later how to create a class)

export¬†default¬†Car;
```
## <a id="a3"></a> a.3) Exporter des objets
### a.3.1) Introduction
Pour mettre √† disposition des objets (fonctions, constantes, objets, classes...) dans un module,
il suffit d'utiliser le mot cl√© **export**.

En JS, si vous souhaitez rendre un objet (fonction, constante, objet, classe...) priv√© au sein 
d'une librairie, il suffit simplement de ne pas l'exporter. En r√©sum√©, les seules √©l√©ments 
publiques sont ce que vous exportez.  
Vous verrez plus tard que si vous programmez en orient√© objet, √† l'aide de classes, la notion 
de public / priv√© n'existe pas en JS. Il faut donc utiliser des modules pour b√©n√©ficier 
d'une sorte d'√©quivalent.

Il existe deux types d'export.

### a.3.1) Default export
Lorsque vous avez un seul objet √† exporter, il est pr√©f√©rable de le faire via un "default export".
D'ailleurs, le Linter utilis√© dans ce cours vous forcera √† le faire, vous ne pourrez pas faire 
un "named export" si vous exportez un seul objet.

Cela permet d'importer cet objet en lui donnant le nom que l'on souhaite.

```js
const Header = () => {
  // ... some code to generate a header
};

export default Header;
```

Ce code permet un "default export" d'une fonction nomm√©e **Header**.

### a.3.2) Named export
Lorsque l'on souhaite exporter plusieurs objets (fonctions, constantes, objets, classes...), 
nous allons g√©n√©ralement le faire via une "Named export".

```js
// ... some code to define three functions

export { setPageTitle, setHeaderTitle, setFooterTitle };
```

Si vous souhaitez plus de d√©tails sur l'export, vous pouvez consulter [la documentation MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export)
[[R.39]](/references/#r39).

## <a id="a4"></a> a.4) Importer des objets
### a.4.1) Introduction
Pour utiliser des objets (fonctions, constantes, objets, classes...) au sein d'un script JS 
provenant de modules, on le fait √† l'aide du mot cl√© **import** et du chemin vers le module √† 
utiliser.

Il existe deux types d'import, en fonction de comment les objets ont √©t√© export√©s.

Il est possible d'importer tant des objets de modules que l'on a cr√©√© soi-m√™me, que de packages 
mis √† disposition via un gestionnaire de packages.

### a.4.2) Default import
Lorsqu'un objet a √©t√© export√© via un "default export", on l'importe en lui donnant le nom 
que l'on souhaite √† l'import et en indiquant le chemin vers le module √† utiliser. 

üëç N√©anmoins, afin de ne pas cr√©er la confusion, nous recommandons d'utiliser le m√™me nom 
que celui utilis√© lors de l'export.

Si l'on souhaite importer la fonction **Header** export√©e pr√©c√©demment :

```js
import Header from ''./Components/Header/Header';
```

üëç Il est recommand√©, lorsqu'on indique le chemin du module que l'on importe, de ne pas indiquer 
l'extension du nom de fichier (**.js**). Cela rend le code plus lisible. D'ailleurs, votre 
Linter va vous forcer √† ne pas indiquer les extensions de vos modules.

ü§ù Il est possible d'utiliser l'autocompletion pour g√©n√©rer le chemin 
vers un "default export module". Il suffit de taper ici **`import Header** et d'appuyer sur 
**Enter** et VS Code g√©n√©rera automatiquement le chemin (path) du module.

Notons qu'ici nous aurions pu donner n'importe quel nom √† la fonction **Header** lors de l'import,
par exemple :

```js
import AmazingHeader from './Components/Header/Header';
```

Nous ne recommandons g√©n√©ralement pas de changer de nom, sauf s'il pouvait y avoir un conflit 
avec une variable qui porterait d√©j√† le m√™me nom.

Il est aussi possible d'importer des objets de packages offerts par la communaut√© via votre 
gestionnaire de package.  
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import.

Pour un "default import", il faut trouver un package qui met √† disposition un seul objet, ce qui 
est peu commun.

En voici un exemple, l'import d'une librairie permettant de r√©aliser des animations :
```js
import anime from 'animejs/lib/anime.es.js';

```

Bien s√ªr, avant d'importer un objet d'un package, il faut l'avoir pr√©alablement install√© üòâ.

### a.4.3) Named import
Lorsqu'un objet a √©t√© export√© via un "Named export", on l'importe en utilisant des accolades 
et en indiquant le chemin vers le module √† utiliser.

Par exemple, pour importer les fonctions **setPageTitle** et **setHeaderTitle**
d√©finies ci-dessus, il suffit de faire :

```js
import { setPageTitle, setHeaderTitle } from './utils/render';;
```

Si l'on souhaitait changer le nom, on pourrait le faire via **as** :

```js
import { setPageTitle as renderPageTitle, setHeaderTitle as renderHeaderTitle} from './utils/render';;
```

On pourrait maintenant appeler la fonction **renderPageTitle** pour (r√©)afficher le titre d'une page.

Il est aussi possible d'importer des objets de packages offerts par la communaut√© via votre 
gestionnaire de package.  
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import, et de 
s√©lectionner le ou les objet(s) qui vous int√©resse entre les accolades.

Voici l'exemple d'une librairie permettant de g√©n√©rer un id :

```js
import { v4 as uuidv4 } from 'uuid';
```

Bien s√ªr, avant d'importer un ou plusieurs objets d'un package, 
il ne faut pas oublier d'installer ce package üòâ.

Si vous souhaitez plus de d√©tails sur l'import, vous pouvez consulter [la documentation MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)
[[R.40]](/references/#r40).

## <a id="a5"></a> a.5) D√©coupe d'une IHM en modules
### a.5.1) Pourquoi d√©couper une IHM en modules ?
Lorsque l'on d√©veloppe une application, il est int√©ressant de d√©couper celle-ci en module afin 
de rendre notre code plus lisible et maintenable.

G√©n√©ralement, si une partie d'un script pourrait √™tre r√©utilisable dans une autre application, 
c'est probablement un signe qu'il serait utile de cr√©er une fonction, et d'offrir cette fonction 
via un module.

Pour le visuel d'une IHM, il est int√©ressant de d√©couper l'UI en composants fonctionnels.
Par exemple, le layout d'un √©cran peut souvent √™tre d√©coup√© en :
- Un header : c'est un composant fonctionnel qui sera r√©utilis√© pour la majorit√© des √©crans.
- Une page : c'est un composant fonctionnel qui sera souvent diff√©rent pour chaque √©cran. On pourrait 
imaginer une d√©coupe ou ce qui d√©finit un √©cran, c'est sa page associ√©e.
- Un footer : c'est un composant fonctionnel qui sera r√©utilis√© pour la majorit√© des √©crans.

Chacun peut donner des noms diff√©rents √† ses √©l√©ments d'UI ainsi que pr√©voir des d√©coupes en 
√©l√©ments √† des niveaux diff√©rents. Ce qui compte, c'est d'√©viter la duplication de code et 
de cr√©er du code lisible.

Nous allons dans ce cours vous proposer une d√©coupe qui ressemble √† ce qui est fait dans certains
frameworks frontend, mais qui ne correspond √† aucunes normes. 
C'est juste une vision parmi d'autres de comment structurer une IHM pour faciliter son d√©veloppement.

Nous allons restructurer le code du site de la pizzeria, notamment afin d'√©viter, lors de l'ajout 
de pages, de la duplication de code. De plus, nous souhaitons que tous nos √©crans soient g√©n√©r√©s 
dynamiquement, via du JS. Ca nous permettra de facilement changer l'affichage.

Pour d√©marrer, nous allons repartir du code du tutoriel du module 2. 
Au sein de votre repo (normalement **web2**) veuillez donc faire un copier coller de votre code 
se trouvant dans **/tutorials/pizzeria/hmi/modern** au sein du nouveau r√©pertoire 
**/tutorials/pizzeria/hmi/structured**.
En cas de souci, vous pouvez utiliser le code du tutoriel du module 2 :
[modern-dynamic-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/modern-dynamic-hmi).

Pour la suite de ce tutoriel, **/tutorials/pizzeria/hmi/structured** est consid√©r√© comme la racine 
du projet.

### a.5.2) Cr√©er une structure logique de r√©pertoires et de modules
Dans ce projet, veuillez cr√©er tous ces nouveux r√©pertoires et fichiers vides pour reprendre nos composants 
fonctionnels :
- **/src/Components** : r√©pertoire qui reprendra tous les composants fonctionnels.
- **/src/Components/Pages** : r√©pertoire qui donnera toutes les pages qui seront accessibles 
en cliquant sur la Navbar.
- **/src/Components/Pages/HomePage.js** : **HomePage** de notre site, c'est l'affichage 
du menu des pizzas et de la liste des boissons.
- **/src/Components/Pages/LoginPage.js** : **LoginPage** de notre site, elle permettra plus tard
aux admins de se connecter.
- **/src/Components/Pages/RegisterPage.js** : **RegisterPage** de notre site, elle 
pourrait permettre de cr√©er des admins.
- **/src/Components/Header** : r√©pertoire qui reprendra le header.
- **/src/Components/Header/Header.js** : module qui reprendra la g√©n√©ration du header via du JS.
- **/src/Components/Footer** : r√©pertoire qui reprendra le footer.
- **/src/Components/Footer/Footer.js** : module qui reprendra la g√©n√©ration du header via du JS.
- **/src/Components/Navbar** : r√©pertoire qui reprendra la Navbar.
- **/src/Components/Navbar/Navbar.js** : module qui reprendra la g√©n√©ration de la Navbar via du JS.

### a.5.3) Cr√©er le layout des √©crans
Il n'est pas utile de g√©n√©rer le squelette de tous les √©crans via du JS.  
Comme nous souhaitons un layout identique pour tous les √©crans, nous allons garder ce layout 
au sein de **/src/index.html**, via des "wrappers" statiques ; ici nous utiliserons 
le **`<header>`**,  le **`<main>`** et le **`<footer>`** comme wrapper. 

Veuillez mettre √† jour le code de **/src/index.html** :

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pizzeria</title>
    <link rel="icon" href="./img/pizza-svgrepo-com.svg" type="image/svg+xml" />
  </head>
  <body class="vh-100 d-flex flex-column">
    <header></header>
    <main class="h-100 flex-grow-1 text-center"></main>
    <footer class="text-center text-white font-weight-bold py-2"></footer>
  </body>
</html>
```

A ce stade-ci, l'application web ne pr√©sente plus le header et le footer, ainsi que le lecteur 
audio. Nous allons g√©n√©rer ces contenus dynamiquement dans la suite du tutoriels, dans les bons 
modules.

### a.5.4) G√©n√©ration des contenus dynamiques
Probablement que g√©n√©rer dynamiquement le header et le footer n'a pas une grande valeur ajout√©e 
√† ce stade-ci car ces composants vont pas ou peu changer lorsqu'on affichera diff√©rents √©crans.  
N√©anmoins, plus tard vous pourriez choisir d'ajouter des fonctionnalit√©s dans ce header ou 
dans le footer : par exemple le choix de la langue, affichage d'une Navbar 
diff√©rente si l'utilisateur est authentifi√© ou pas....

Pour g√©n√©rer un composant fonctionnel, nous devons d√©cider de comment faire le rendu de ceux-ci.
Pour ce cours, nous avons d√©cid√© que chaque composant fonctionnel est une fonction, et que cette 
fonction est responsable de se rendre au sein d'un "wrapper" existant.

Commen√ßons par compl√©ter la **HomePage**. Tout son code se trouve actuellement dans 
**index.js**. Nous devons faire un petit refactor afin de cr√©er une fonction **HomePage()** qui 
sera appel√©e dans **index.js** au chargement de la page. Notons que la **HomePage** ne doit plus 
s'occuper du **footer**. C'est pourquoi la fonction **renderPizzaImage** a √©t√© supprim√©e.  

Veuillez compl√©ter le code de **HomePage.js** :

```js
const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const DRINKS = [
  {
    id: 1,
    title: 'Lemonade',
    content: 'Sparkling water, lemon, ice cubes',
  },
  {
    id: 2,
    title: 'Ice tea',
    content: 'Mint, ginger, water',
  },
  {
    id: 3,
    title: 'Exotic Kombucha',
    content: 'Mango, Sparkling water, Fermented tea',
  },
];

const HomePage = () => {
  renderMenuFromString(MENU);

  attachOnMouseEventsToGoGreen();

  renderDrinksFromNodes(DRINKS);
};

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}

function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}

function renderDrinksFromNodes(drinks) {
  const drinksTableAsNode = getDrinksTableAsNode(drinks);

  const main = document.querySelector('main');

  main.appendChild(drinksTableAsNode);
}

function getDrinksTableAsNode(drinks) {
  const tableWrapper = document.createElement('div');
  tableWrapper.className = 'table-responsive pt-5';
  const table = document.createElement('table');
  const tbody = document.createElement('tbody');
  table.id = 'table-drinks';
  table.className = 'table table-success';
  tableWrapper.appendChild(table);
  table.appendChild(tbody);
  const header = document.createElement('tr');
  const header1 = document.createElement('th');
  header1.innerText = 'Drink';
  const header2 = document.createElement('th');
  header2.innerText = 'Description';
  header.appendChild(header1);
  header.appendChild(header2);
  tbody.appendChild(header);

  drinks?.forEach((drink) => {
    const line = document.createElement('tr');
    const title = document.createElement('td');
    const description = document.createElement('td');
    title.innerText = drink.title;
    description.innerText = drink.content;
    line.appendChild(title);
    line.appendChild(description);
    tbody.appendChild(line);
  });

  table.addEventListener('mouseover', () => {
    table.className = 'table table-danger';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-success';
  });

  return tableWrapper;
}

export default HomePage;
```

üí≠ Veuillez bien vous assurer que vous comprenez chaque ligne de code. Il n'y a pas de nouveau 
code √† ce stade-ci.

Ce code pourrait √™tre nettoy√©. En effet, les donn√©es (**MENU** et **DRINKS**) devrait se trouver 
dans un autre module, afin de s√©parer les donn√©es de la logique. Nous g√©rons l'aspect "donn√©es" 
plus tard.

Maintenant, **index.js** va appeler la **HomePage**.  
Il faut donc importer la fonction **HomePage** et l'appeler.  
Voici le code de **index.js** √† ce stade-ci :

```js
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

import HomePage from './Components/Pages/HomePage';

HomePage();
```


Nous allons g√©n√©rer le header, sans se soucier √† ce stade-ci de la Navbar.
Comme nous souhaitons que le lecteur audio puisse √™tre visible dans tous les √©crans,
celui-di sera ajout√© au header. 
Nous allons aussi au sein du Header ajouter un "wrapper" dans lequel la Navbar pourra √™tre 
affich√©e.  
Voici le code de **Header.js** :

```js
import sound from '../../sound/Infecticide-11-Pizza-Spinoza.mp3';

const Header = () => {
  renderTitleAndWrapper();
  renderAudioPlayer();
  onBodyClick();
};

function renderTitleAndWrapper() {
  const header = document.querySelector('header');
  header.innerHTML = `<h1 class="animate__animated animate__bounce text-center">
  We love Pizza
  </h1>
  <div id="navbarWrapper">
  </div>
  `;
}

function renderAudioPlayer() {
  const header = document.querySelector('header');

  header.innerHTML += `
  <div class="text-center">
    <audio id="audioPlayer" controls autoplay class="mt-3">
    <source src="${sound}" type="audio/mpeg" />
    Your browser does not support the audio element.
    </audio>
  </div>
  `;
}

function onBodyClick() {
  const body = document.querySelector('body');
  body.addEventListener('click', startOrStopSound);
}

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

export default Header;
```

Pour appeler le **Header**, il suffit de compl√©ter **index.js** :

```js {6,8}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

import HomePage from './Components/Pages/HomePage';
import Header from './Components/Header/Header';

Header();
HomePage();
```

On voit que le style permettant les animations, tout comme Bootstrap, ne doivent pas √™tre 
charg√© dans chacun des modules. Comme cela est fait dans le point d'entr√©e du programme **index.js**,
ces styles sont disponibles dans tous les modules appel√©s par le biais d'**index.js**.

Nous allons g√©n√©rer le footer.

```js
import pizzaImage from '../../img/pizza2.jpg';
import logo from '../../img/js-logo.png';

const Footer = () => {
  const footer = document.querySelector('footer');
  footer.innerHTML = `<h1 class="animate__animated animate__bounce animate__delay-2s text-center">
  But we also love JS
</h1>`;

  renderSmallImage(footer, logo);
  renderSmallImage(footer, pizzaImage);
};

export default Footer;

function renderSmallImage(wrapper, url) {
  const image = new Image(); // or document.createElement('img');
  image.src = url;
  image.height = 50;
  wrapper.appendChild(image);
}
```

Pour appeler le **Footer**, il suffit de compl√©ter **index.js** :

```js {7,11}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

import HomePage from './Components/Pages/HomePage';
import Header from './Components/Header/Header';
import Footer from './Components/Footer/Footer';

Header();
HomePage();
Footer();
```

Veuillez ex√©cuter votre application pour vous assurer que celle-ci offre la m√™me fonctionnalit√© 
qu'au tutoriel du module 2.

Nous allons maintenant rajouter des pages et travailler l'aspect navigation entre les pages.

# <a id="b"></a> b) Le routage des √©crans
## <a id="b1"></a> b.1) Introduction

Lorsqu'on parle d'une IHM, nous souhaitons g√©n√©ralement afficher diff√©rents √©crans en r√©agissant 
aux actions des utilisateurs.

Le routage (ou routing en anglais) est ce qui rend possible l'affichage de diff√©rents √©crans.

Il n'y a pas de normes imposant un syst√®me de routage, il existe une multitude de fa√ßon d'afficher
diff√©rents √©crans, soit :
- **une simple gestion de wrappers et de g√©n√©ration dynamique d'HTML** ; c'est l'option la plus l√©g√®re qui a √©t√© 
s√©lectionn√©e pour ce cours.
- **via l'utilisation de Web Components API** [[R.41]](/references/#r41) ; fa√ßon int√©ressante de 
faire du web qui demanderait un cours d√©di√© √† cette technologie ; d√®s lors cela n'a pas √©t√© s√©lectionn√© 
comme technologie pour ce cours de JS ;
- **via l'utilisation d'un langage de templating** : Handlebars [[R.42]](/references/#r42), Mustache‚Ä¶ ; 
cette technologie n'est pas appropri√©e lorsque l'on souhaite r√©agir √† beaucoup d'√©v√©nements diff√©rents.
- **via l'utilisation de librairies l√©g√®res**, comme par exemple Lit [[R.43]](/references/#r43) 
ou **[[R.44]](/references/#r44)** ; nous pr√©f√©rons l'id√©e du Vanilla JS pour ce cours-ci plut√¥t 
que de nous "marier" √† une technologie.
- **via l'utilisation de frameworks / librairies** : React, Vue, Angular, tous ces frameworks 
mettent √† disposition des librairies pour g√©rer le routage. N√©anmoins, le choix de d√©part fait 
pour ce cours est de ne pas utiliser de framework pour la cr√©ation de nos IHM.

Nous allons voir ensemble comment via une simple gestion de wrapper et de g√©n√©ration dynamique 
d'HTML nous pouvons assurer le routage de nos √©crans.

## <a id="b2"></a>  b.2) Ajout d'une Navbar
Nous souhaitons cr√©er une Navbar √† l'aide de JS et de Bootstrap afin de pouvoir afficher 
diff√©rentes pages : **HomePage**, **LoginPage** ou **RegisterPage**.  

Dans un premier temps, nous allons cr√©er les deux nouvelles pages.

Veuillez compl√©ter le code de **/src/Component/Pages/Login.js** :

```js
import { clearPage, renderPageTitle } from '../../utils/render';

const LoginPage = () => {
  clearPage();
  renderPageTitle('Login');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Login';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
}

export default LoginPage;
```

Veuillez compl√©ter le code de **/src/Component/Pages/Register.js** :

```js
import { clearPage, renderPageTitle } from '../../utils/render';

const RegisterPage = () => {
  clearPage();
  renderPageTitle('Register');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Register';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
}

export default RegisterPage;
```

Avant d'afficher une page, nous nous assurons de faire un "clear" du "wrapper" 
utilis√© pour afficher les pages (**main**). Comme nous allons utiliser le "clear" dans de 
multiples pages, et bien, afin d'√©viter des duplications de code, veuillez ajouter un nouveau
module **render.js** dans un nouveau r√©pertoire **/src/utils**. De plus, nous allons y ajouter 
une fonction permettant de donner un titre √† une page. Voici le code de **/src/utils/render.js** :

```js
const clearPage = () => {
  const main = document.querySelector('main');
  main.innerHTML = '';
};

const renderPageTitle = (title) => {
  if (!title) return;
  const main = document.querySelector('main');
  const pageTitle = document.createElement('h4');
  pageTitle.innerText = title;
  main.appendChild(pageTitle);
};

export { clearPage, renderPageTitle };
```

Afin de pouvoir navigurer entre les pages, nous allons cr√©er la Navbar.  
Veuillez compl√©ter **/src/Component/Navbar/Navbar.js** :

```js
// eslint-disable-next-line no-unused-vars
import { Navbar as BootstrapNavbar } from 'bootstrap';
import HomePage from '../Pages/HomePage';
import LoginPage from '../Pages/LoginPage';
import RegisterPage from '../Pages/RegisterPage';

const Navbar = () => {
  renderNavbar();
  onNavBarClick();
};

function renderNavbar() {
  const navbar = document.querySelector('#navbarWrapper');
  navbar.innerHTML = `
  <nav class="navbar navbar-expand-lg navbar-light bg-danger">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">e-Pizzeria</a>
          <button
            class="navbar-toggler"
            type="button"
            data-bs-toggle="collapse"
            data-bs-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#">Home</a>
              </li>
              <li id="loginItem" class="nav-item">
                <a class="nav-link" href="#">Login</a>
              </li>
              <li id="registerItem" class="nav-item">
                <a class="nav-link" href="#">Register</a>
              </li>           
            </ul>
          </div>
        </div>
      </nav>
  `;
}

function onNavBarClick() {
  const navItems = document.querySelectorAll('.nav-link');

  navItems.forEach((item) => {
    item.addEventListener('click', (e) => {
      console.log(`click on ${e.target.innerHTML} navbar item`);
      if (e.target.innerHTML === 'Home') {
        HomePage();
      } else if (e.target.innerHTML === 'Login') {
        LoginPage();
      } else if (e.target.innerHTML === 'Register') {
        RegisterPage();
      }
    });
  });
}

export default Navbar;
```

La gestion du routage de la bonne page, c'est-√†-dire l'affichage de la page correspondant 
√† l'√©l√©ment de la Navbar qui a √©t√© cliqu√©, est simple. 
Lors d'un clic sur un √©l√©ment de la Navbar, on identifie cet √©l√©ment gr√¢ce au texte associ√© 
√† celui-ci (via **`e.target.innerHTML`**).  
Ensuite, la fonction associ√©e √† la page est appel√©e.

Par exemple, pour rendre la page de login, il suffit d'appeler **`LoginPage()`** 
du module **`/src/Components/Pages/LoginPage`**.


Finalement, nous allons appeler la Navbar au sein d'**index.js** :

```js {8,11}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

import HomePage from './Components/Pages/HomePage';
import Header from './Components/Header/Header';
import Footer from './Components/Footer/Footer';
import Navbar from './Components/Navbar/Navbar';

Header();
Navbar();
HomePage();
Footer();
```

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**structured-hmi**".

En cas de souci, vous pouvez acc√©der au code de cette √©tape du tutoriel ici :
[structured-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/structured-hmi).