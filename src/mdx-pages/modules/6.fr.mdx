---
title: "Module 6 : SPA & comms"
description: "Cr√©ation de SPA et gestion des communications entre une RESTful API et une IHM"
---

# Module 6 : SPA & comms
Ce module vous offre principalement la cr√©ation de SPA et la gestion des communications asynchrones entre une RESTful API et une IHM.

A cette √©tape-ci, nous allons simplement int√©grer des RESTful API au sein d'IHM. 
C'est donc principalement du d√©veloppement frontend que nous allons faire, √† l'inverse des deux derniers modules o√π nous avons fait que du d√©veloppement backend.

Voici les sujets trait√©s :
- a) [Introduction aux Single Page Applications](#a)
  - a.1) [Caract√©ristiques et workflow associ√©s √† une SPA](#a1)
  - a.2) [Architectures associ√©es √† une SPA](#a2)
  - a.3) [Gestion des communications d'une SPA](#a3)
- b) [Gestion des communications d'une SPA](#b)
  - b.1) [Introduction aux protocoles de communications d'une SPA](#b1)
  - b.2) [Introduction aux librairies li√©es aux requ√™tes HTTP](#b2)
  - b.3) [Requ√™tes asynchrones & introduction aux promesses](#b3)
- c) [Gestion de la s√©curit√© des communications du browser](#c)
  - c.1) [Single Origin Policy & CORS](#c1)
  - c.2) [Relaxer la s√©curit√© via des CORS](#c2)
  - c.3) [Contourner le SOP via un proxy](#c3)
- d) [Programmation asynchrone √† l'aide de promesses & async / await](#d)

<br/>

# <a id="a"></a> a) Introduction aux Single Page Applications
## <a id="a1"></a> a.1) Caract√©ristiques et workflow associ√©s √† une SPA
Une SPA (Single Page Application) offre de belles caract√©ristiques :
- **Pas de rechargement de page pendant l'utilisation** : en effet, on t√©l√©charge une seule fois 
l'ensemble du frontend (et donc de toutes les pages) ;
- **La r√©√©criture dynamique du contenu de la page** : lorsque l'on navigue d'une page √† une autre, 
on change que les parties de l'IHM qui doivent √™tre mises √† jour.
- **Pas d'interruption de l'exp√©rience de l'utilisateur** : lorsque l'utilisateur, via ses actions, 
am√®ne par exemple √† un appel √† une API, l'IHM reste disponible. Le browser peut r√©aliser des actions 
de mani√®re asynchrone (ou autrement dit, en parall√®le) et ne bloque pas l'exp√©rience utilisateur 
lors de long chargements (√† l'exception bien s√ªr du tout premier acc√®s √† l'application n√©cessitant 
le chargement complet du frontend).

Voici un exemple de workflow associ√© √† la SPA qui g√©rera le site de la pizzeria, afin d'afficher le 
menu au sein de l'IHM :

<ScrollableImage name="readPizzas.png" minWidth="523px" maxWidth="523px" />
<figcaption>Exemple de Workflow classique d'une SPA</figcaption>

Une fois la page **index.html** charg√©e par le browser, celui-ci va faire des appels multiples 
au serveur de fichiers statiques afin de t√©l√©charger tous les assets n√©cessaires √† l'IHM.

Une fois l'IHM charg√©e, le browser lance en parall√®le un appel √† la RESTful API pour lire 
toutes les pizzas, tout en √©tant √† l'√©coute d'√©v√©nements qui pourrait se passer au niveau de 
l'IHM.

## <a id="a2"></a> a.2) Architectures associ√©es √† une SPA
Il existe diff√©rentes architectures associ√©es √† une SPA.

Dans le cadre de ce cours, nous avons choisi d'avoir une IHM qui soit enti√®rement ind√©pendante 
de la RESTful API :

<ScrollableImage name="independentFrontBackSPA.png" minWidth="914px" maxWidth="914px" />
<figcaption>Frontend ind√©pendant de l'API</figcaption>

Lors du d√©veloppement, nous utiliserons donc le boilerplate du cours pour avoir une IHM qui soit 
enti√®rement ind√©pendante de l'API. Webpack sera utilis√© comme serveur de fichiers statiques 
lors du d√©velopppement. Notons qu'il est possible d'utiliser d'autres serveurs lors du d√©veloppement, 
comme **Live Server** de VS Code, ou un package npm comme **serve**.
En production, lorsque nous mettrons l'IHM sur le web, nous devrons 
nous tourner vers un autre serveur de fichiers statiques.

Voici l'architecture de l'API telle que d√©velopp√©e dans les modules pr√©c√©dents :

<ScrollableImage name="architecture.png" minWidth="859px" maxWidth="859px" />
<figcaption>RESTful API ind√©pendante du frontend</figcaption>

Nous voyons que ces architectures (frontend & backend) am√®nent √† deux projets bien distincts, un projet pour le frontend, 
et un autre pour le backend.

Pour votre information, il est aussi possible d'avoir une architecture monolithique pour une SPA.
Dans ce sc√©nario, la RESTful API s'occupe tant de fournir l'IHM via un serveur de fichiers statiques 
que d'offrir les op√©rations sur les ressources via un serveur dynamique.

Voici un exemple d'architecture monolithique possible √† l'aide de Node.js :

<ScrollableImage name="monolithicSPA.png" minWidth="758px" maxWidth="758px" />
<figcaption>SPA monolithique sous Express : chargement du frontend</figcaption>

Une fois le frontend charg√©, le browser pourra faire appel aux API et c'est le ou les router(s) 
de l'API qui prendront en compte les appels.

Nous n'appliquerons pas cette architecture dans le cadre de ce cours. N√©anmoins, vous aurez toutes les 
connaissances pour l'appliquer si vous le souhaitez.

Voici en r√©sum√© les caract√©ristiques des deux architectures pr√©sent√©es ci-dessus :
- SPA dont le frontend est ind√©pendant du backend :
    - Frontend avec Serveur de fichiers statiques pour d√©ployer l'IHM
    - 2 serveurs : 1 serveur pour le frontend, 1 serveur pour le backend
    - Ports diff√©rents pour le Frontend & le Backend
- SPA monolithique : 
    - RESTful API avec Serveur de fichiers statiques pour d√©ployer l'IHM
    - M√™me serveur pour d√©ployer le backend & le frontend 
    - M√™me port pour le frontend & le backend


Pour information, les ports permettent √† un m√™me appareil de communiquer sur un r√©seau en offrant 
plusieurs services. Chaque service, ou application, communique sur un et un seul port.

# <a id="b"></a> b) Gestion des communications d'une SPA
## <a id="b1"></a>  b.1) Introduction aux protocoles de communications d'une SPA
Quelles protocoles & techniques principales allons nous utiliser pour communiquer au sein d'une SPA ?  
Il en existe plusieurs. Dans le cadre de ce cours, nous allons simplement voir la technique 
principale, **AJAX** (ou **A**synchronous **Ja**vaScript and **X**ML).

**AJAX** est une combinaison de technologies (HTML/CSS, DOM, JSON ou XML, XMLHttpRequest, JS) 
pour r√©aliser une application web asynchrone.  
C'est-√†-dire que le frontend reste disponible aux actions des utilisateurs m√™me lorsqu'il fait des 
requ√™tes HTTP asynchrone √† des API.
Le transport de donn√©es entre le frontend et l'API se faisait autrefois via **XML**, or actuellement, 
il se fait via **JSON**.

Notons que dans le cadre d'architectures MPA "old school" (non vues dans le cadre de ce cours), 
g√©n√©ralement, l'appel aux API se fait pas par le frontend, mais par le backend. Pendant toute la dur√©e de l'appel du frontend au backend, 
celui-ci reste en attente car la demande faite au backend est synchrone : par exemple, lorsqu'un 
formulaire est envoy√© au serveur, l'action du formulaire est de faire l'appel √† une nouvelle page 
au serveur (via la propri√©t√© "action" du formulaire HTML) ; jusqu'√† la r√©ponse du backend, aucune 
action d'un utilisateur ne sera possible au niveau de l'IHM.

Il existe d'autres moyens de communiquer entre applications web. Par exemple, les **websockets** 
sont une technologie de communication temps-r√©el client / serveur et bidirectionnelle.  
A la fin de ce cours, vous devriez √™tre apte √† d√©couvrir cette technologie par vous m√™me si vous
le souhaitiez.

Avec **AJAX**, c'est le client qui doit initier la communication. Ca n'est pas le cas pour les 
**websockets**, le serveur peut le faire. Ainsi, avec **AJAX**, le client doit cr√©er une connexion HTTP √† chaque requ√™te.

## <a id="b2"></a>  b.2) Introduction aux librairies li√©es aux requ√™tes HTTP
Voici une liste de librairies bien connues pouvant parfois √™tre utilis√©e tant au niveau d'un browser (frontend) que via Node.js (backend) :

<ScrollableImage name="ajax.png" minWidth="569px" maxWidth="569px" />
<figcaption>Comparaison de librairies AJAX/HTTP [R.60]</figcaption>

Ancienement, il y a environ 20 ans, c'est la librairie **XMLHttpRequest** qui √©tait utilis√©e.
Puis la librairie **ajax** avait pris l'ascendant via la m√©thode **$.ajax()**.

Le standard actuel pour le Vanilla JS, au niveau des browser, c'est la **Fetch API**. Dans ce cours, Nous allons utiliser cette API offerte par tous les browsers pour faire des requ√™tes vers nos API.  
Notez que si vous souhaitez un jour utiliser une librairie pour vos requ√™tes HTTP, probablement que la plus utilis√©e actuellement c'est **axios**.

## <a id="b3"></a>  b.3) Requ√™tes asynchrones & introduction aux promesses
La m√©thode **fetch** permet de faire des requ√™tes HTTP d'un browser vers des API.

Cette m√©thode est asynchrone, c'est-√†-dire quelle n'est pas bloquante, elle renvoie des promesses de r√©sultats via des objets **Promise**. Nous allons de mani√®re intuitive d√©couvrir la programmation asynchrone. Nous pourrons voir plus en d√©tails par la suite ce qu'est la programmation asynchrone √† l'aide de **promises** (les promesses).

Si un jour vous avez besoin de plus de documentation sur la m√©thode **fetch**, n'h√©sitez pas √† consulter la [documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) [[R.61]](/references/#r61).

Pour la pizzeria, l'IHM que nous avons d√©velopp√© au module 3 s'est termin√©e avec ce code :
[routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/routing-hmi)).

Cette IHM √©tait enti√®rement frontend, le **MENU** √©tant hardcod√© dans la **HomePage**.  
Nous souhaitons maintenant changer cela, l'IHM doit faire une requ√™te **fetch** √† notre RESTful API d√©velopp√©e au module 5 : 
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Nous n'allons donc plus utiliser REST Client mais une fonction offerte par le browser pour faire l'√©quivalent de cette requ√™te :
```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Veuillez d√©marrer la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Nous allons maintenant continuer le d√©veloppement de l'IHM [routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/routing-hmi).

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/hmi/basic-fetch** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/hmi/routing-hmi** (ou [routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/routing-hmi).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/hmi/basic-fetch**.

Veuillez mettre √† jour le fichier **src/Components/Pages/HomePage.js** en supprimant l'array **MENU** et en rempla√ßant la ligne **`renderMenuFromString(pizzas);`** par cette requ√™te **fetch** pour lire toutes les pizzas :

```js numbered {4-14}
const HomePage = () => {
  clearPage();

  fetch('http://localhost:3000/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });

  attachOnMouseEventsToGoGreen();

  renderDrinksFromNodes(DRINKS);
};
```

Veuillez ex√©cuter le frontend.  
Ca ne fonctionne pas, nous obtenons ces erreurs dans la console du browser :

<ScrollableImage name="errors.png" minWidth="589px" maxWidth="589px" />

La premi√®re erreur, est tr√®s int√©ressante pour comprendre la nature asynchrone de la fonction 
**fetch**. 

Par d√©faut, la fonction **fetch** fait une requ√™te de type **GET**.  
Ici on a donc demand√© √† la RESTful API, qui tourne sur le port **8080** de votre machine locale, la lecture (requ√™te GET) de toutes les ressources de type "pizzas" :
```js
  fetch('http://localhost:3000/pizzas')
};
```

Comme la fonction **fetch** est asynchrone, le programme principal ne se bloque pas et n'attend 
donc pas les r√©sultats de l'appel de **fetch**. Directement apr√®s le d√©but du **fetch**, on passe √† la ligne 16 du morceau de code pr√©c√©dent : **`attachOnMouseEventsToGoGreen(pizzas);`**.  
Dans cette fonction, voici ce qui est fait :
```js numbered {2-3}
function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}
```

On essaie d'acc√©der √† la table HTML qui doit √™tre cr√©√©e par la m√©thode **`renderMenuFromString()`** qui n'a pas encore √©t√© appel√©e...  
üí≠ Mais pourquoi la table n'a pas √©t√© cr√©√©e alors que le morceau de code **`attachOnMouseEventsToGoGreen(pizzas);`** se trouve plus haut ?  
H√© bien c'est √ßa la programmation asynchrone, √ßa n'est qu'une fois le programme principal ex√©cut√© que les t√¢ches asynchrones, de priorit√© plus basses, pourront s'executer.

Comment r√©ecrire ce code pour cha√Æner l'appel de **`attachOnMouseEventsToGoGreen(pizzas);`** 
au succ√®s de l'op√©ration **fetch** ?

La m√©thode **fetch** renvoie une **Promise**, qui est un objet repr√©sentant un √©tat interm√©diaire d'une op√©ration. Le code des callbacks s'ex√©cute quand la t√¢che asynchrone est finie avec succ√®s ou si la t√¢che √©choue.

Les √©tats d'une promesse sont les suivants : 
- **pending** : √©tat initial, 
- **fulfilled** : l'op√©ration asynchrone a √©t√© termin√©e avec succ√®s ; par exemple la requ√™te 
fetch() a obtenu un flux de donn√©es avec la RESTful API, 
- **rejected** : l'op√©ration asynchrone a √©chou√©e ; par exemple la requ√™te **fetch** est mal construite.

Pour r√©cup√©rer le r√©sultat d'une m√©thode asynchrone, on va faire appel :
- **.then( callback )** : ce morceau de code permet de cha√Æner des traitements asynchrones. Par exemple, √† la fin du premier traitement asynchrone associ√© au **fetch()**, on appelle  
```js numbered {2-5}
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```
La callback sera appel√©e et recevra comme param√®tre un objet de type **Response**, un objet ne contenant pas encore le contenu du body de la r√©ponse sous forme d'un objet JS. En fait, **Response.body** est un flux de donn√©es (un stream), il faudra donc faire appel √† un traitement asynchrone pour obtenir le contenu du body sous forme d'un objet JS.  
C'est ce qui est fait en renvoyant **`return response.json();`** : la fonction **json()** renvoie une promesse, c'est √† dire qu'une fois le traitement termin√©, nous pourrons cha√Æner celui-ci via un autre **.then()**.
C'est ainsi que nous cha√Ænons, une fois le **body** (au format JSON) disponible, l'appel d'une deuxi√®me callback qui s'occupe de faire un render du menu de la pizzeria. Cette deuxi√®me callback recevra en param√®tre le body de la r√©ponse sous forme d'un objet JS :
```js numbered {6-8}
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```

Si nous souhaitons cha√Æner l'ajout des √©couteurs d'√©v√©nements sur la table HTML, c'est donc dans cette callback qu'il faut le faire. Veuillez mettre √† jour le code afin d'√©liminer la premi√®re erreur qu'il y avait dans la console :
```js numbered {4-16}
const HomePage = () => {
  clearPage();

  fetch('http://localhost:3000/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
      attachOnMouseEventsToGoGreen();
      renderDrinksFromNodes(DRINKS);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });  
};
```

La console de votre browser devrait afficher une erreur en moins.

- **.catch( callback )** : ce morceau de code permet d'ex√©cuter une callback lorsque la t√¢che asynchrone associ√©e √† la promesse √©choue. Dans le code, on voit que l'on affiche juste un message dans la console :
```js numbered {11-13}
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```

- **.finally( callback )** : si l'on souhaite ex√©cuter une callback quelque soit le r√©sultat de la promesse, en cas de succ√®s ou d'√©chec.

‚ö° Pour le cha√Ænage des traitements via plusieurs callback appel√©es au sein de **.then()**, cela n'est possible que s'il y a un **return** dans les callback.

En effet, si une callback dans la gestion de promesses retourne :
- **Une valeur** : la promesse retourn√©e par **then** est r√©solue avec la valeur.
- **Pas de valeur** : la promesse retourn√©e par **then** est r√©solue avec **undefined**.
- **Une autre promesse "pending"**: la promesse retourn√©e par **then** est r√©solue/rejet√©e √† la suite de la r√©solution/rejet de la promesse retourn√©e par la callback.

Pour info, autrefois, pour la programmation asynchrone en JS, nous utilisions simplement les callbacks, des fonctions que l'on passait en argument d'autres fonctions. Le code pouvait facilement devenir illisible et donc difficilement maintenable.

üí≠ OK, nous avons appris les fondements de la programmation asynchrone moderne en JS...  
Mais √ßa ne fonctionne pas, nous n'avons toujours l'erreur associ√©e aux "CORS policy".  
Cette erreur, c'est un mur classique contre lequel tous les programmeurs web doivent se cogner au moins une fois dans leur carri√®re.


# <a id="c"></a> c) Gestion de la s√©curit√© des communications du browser
## <a id="c1"></a> c.1) Single Origin Policy & CORS
La **Single Origin Policy** (**SOP**) sont des r√®gles appliqu√©es par le browser afin :
- de restraindre les interactions entre un document ou script charg√© par une origine avec une ressource d'une autre origine
- d'isoler des documents ou scripts malicieux, afin de r√©duire le risque des attaques.

Deux URL ont une m√™me **origine** si ces caract√©ristiques sont les m√™mes :
- **protocole** ;
- **port** ;
- **host** ; l'URL pointe vers le m√™me appareil connect√© √† internet ou √† un r√©seau local


Il est possible de relaxer la s√©curit√© via des **Cross Origin Resource Sharing** (**CORS**).  
**CORS** est un m√©chanisme qui utilise des headers HTTP pour indiquer aux browsers qu'ils peuvent autoriser les acc√®s √† des ressources d'origines diff√©rentes.

Cela signifie qu'une application web qui utilise une API ne peut le faire que si les ressources demand√©es √† l'API proviennent d'une m√™me origine, √† moins que la r√©ponse de l'API inclue les bonnes **CORS** (via des header HTTP).

Si l'on autorise trop d'origine, voici un exemple classique d'attaque :

<ScrollableImage name="cors-issue.png" minWidth="500px" maxWidth="700px" />

Imaginez qu'un site d'une banque ne soit pas s√©curis√© avec des techniques modernes. Ce site utiliserait une IHM (`https://my-bank.com`), qui, via un formulaire, permettrait de faire un versement, sous r√©serve d'envoyer un cookie qui contiendrait une variable de session (simple m√©canisme de s√©curit√©) lors d'une requ√™te √† l'API de la banque.

Maintenant, prenons le cas d'un utilisateur qui adore jouer sur le web, un gamer en puissance. Il joue √† un jeu de pinguins, mais soudainement, il est redirig√© vers un site malicieux (`https://malicious.com`), qui lui offre un nouveau jeu avec des dinosaures. Ce site malicieux, en arri√®re plan, pourrait faire une requ√™te vers la m√™me API utilis√©e par `my-bank`.  
Comme c'est le m√™me browser utilis√© par notre gamer, tant pour faire ses virements, que pour jouer, toute requ√™te faite vers `https://api.my-bank.com` enverra d'office les cookies existants et associ√©s au domaine `api.my-bank.com`.
Les r√©sultats peuvent √™tre dramatiques, l'attaquant peut faire des versements jusqu'√† vider le compte de notre pauvre gamer.

Bien s√ªr, gr√¢ce √† la **SOP** appliqu√©e par nos browser, par d√©faut, d√®s que le site malicieux communique avec l'API de la banque, celui-ci bloque l'acc√®s aux ressources de l'API car l'origine du site malicieux est diff√©rente de l'origine de l'API.

Les **CORS** permettent de relacher la s√©curit√©, afin notamment, dans le sc√©nario √©voqu√©, d'autoriser l'origine `https://my-bank.com` √† acc√©der √† l'origine `https://api.my-bank.com`. En effet, c'est ce que le site de la banque souhaite.  
Par contre, si la banque poss√®de des d√©veloppeurs nuls au niveau s√©curit√© et que ceux-ci autorisent toutes les origines √† interroger l'API, l√†, nous pourrions arriver au hacking d√©crit ci-dessus.

Attention √† ne pas confondre les attaques associ√©es √† une mauvaise gestion des **CORS** aux attaques **XSS**. Les attaques **XSS**, ou **Cross-Site Scripting**, sont un type d'injection de scripts malicieux dans une application web.

Imaginez le forum web de la banque d√©crite pr√©c√©dente et ce sc√©nario :

<ScrollableImage name="xss.png" minWidth="500px" maxWidth="700px" />

L'API de la banque permet d'enregistrer des messages qui sont associ√©s √† des forums sur lesquels leurs clients peuvent poster des messages.  
Si l'API de la banque √©tait mal s√©curis√©e et qu'elle permettait d'enregistrer n'importe quels types d'information en tant que "messages" du forum, il serait possible √† un attaquant d'injecter du JS malicieux dans l'API.  
Plus tard, lors de l'affichage des messages par le forum de la banque (`https://forum.my-bank.com
`), le JS malicieux pourra s'ex√©cuter dans le browser de n'importe quel utilisateur, y-compris le gamer d√©crit ci-dessus ! 
Et vous avez vu que via du JS, on peut envoyer de l'information n'importe o√π, notamment √† l'aide de **fetch**. Ce qui permettrait donc √† notre hacker, via son script malicieux, d'envoyer des cookies contenant des infos sensibles √† son API malicieuse, en vue de futures attaques encore plus malicieuses, comme notamment vider son compte en banque.

La protection contre des attaques XSS se fait √† diff√©rents niveaux. Ca n'est pas l'objet de ce cours, mais nous verrons n√©anmoins, plus tard, certaines techniques pour √©viter les attaques XSS.

Nous allons voir comment nous pouvons communiquer entre un frontend et une API fonctionnant sous deux origines diff√©rentes, √† l'aide de deux techniques diff√©rentes.

## <a id="c2"></a> c.2) Relaxer la s√©curit√© via des CORS
A cette partie-ci, nous allons voir comment mettre √† jour une API afin que dans chaque r√©ponse faite √† un client, on ajoute un header permettant d'autoriser une ou plusieurs origines.

Nous allons partir de la derni√®re version de la RESTful de pizzas.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/cors** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/api/fat-model** (ou [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/cors**.

Dans ce projet, veuillez installer le package **cors** : 
``` bash
npm i cors
``` 

Nous allons configurer les headers de la RESTful API √† l'aide du middleware **cors** offert par 
la librairie **cors**.

Pour configurer et utiliser les **CORS**, veuillez mettre √† jour le fichier **/app.js** :

```js numbered {4-8,21}
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const cors = require('cors');

const corsOptions = {
  origin: 'http://localhost:8080',
};

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');

const app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', cors(corsOptions), pizzaRouter);

module.exports = app;
```

Ici, nous pr√©cisons que l'API doit autoriser l'origine associ√©e au port sur lequel tourne 
le serveur de fichiers statiques de Webpack (**8080**). Notons que nous n'avons pas rel√¢ch√© la s√©curit√© pour les ressources de type "users", la fonction middleware **cors** n'est pas appel√©e au niveau du router de pizza.

Veuillez vous assurer que l'API **fat-model** est ferm√©e et veuillez d√©marrer votre nouvelle version de l'API (**api-cors**).

Il vous reste √† vous assurer que votre frontend (**/web2/tutorials/pizzeria/hmi/basic-fetch**) est lui aussi bien d√©marr√© et peut enfin r√©aliser son fetch impl√©ment√© dans **HomePage.js**.

Tout fonctionne correctement ?

Normalement oui, vous devriez avoir le site de la pizzeria qui affiche le menu des pizzas suite √† un appel √† l'API (api-cors).

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**api-cors**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
- pour l'API : [api-cors](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cors).
- pour le frontend : 
[basic-fetch-no-proxy](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).


üí≠ OK, √ßa fonctionne bien... Mais cela est possible seulement si nous sommes les propri√©taires de la RESTful API. Maintenant, que faire si une API tierce doit √™tre int√©gr√©e dans notre frontend ?  
Imaginez que vous souhaitez int√©grer une op√©ration d'une API offerte par Google...  
Pensez-vous que vous pouvez leur donner un coup de t√©l√©phone et dire : "Google, peux-tu STP autoriser l'origine associ√©e √† mon site web ?".

Il y a peu de chances... 
Nous allons donc voir un autre moyen de contourner la **SOP** (Single Origin Policy) impos√©e par le browser.

## <a id="c3"></a> c.3) Contourner le SOP via un proxy
Il est possible de mettre en place un proxy au niveau du frontend afin de faire croire au browser que l'API et le frontend ont la m√™me origine.

Ici, nous sommes dans la situation o√π nous ne souhaitons pas, ou nous n'avons pas les moyens, d'ajouter des origines au niveau de l'API.

Pour le tutoriel, veuillez donc stopper l'ex√©cution de l'API nomm√©e **api-cors**.

Veuillez d√©marrer l'API pr√©c√©dente d√©velopp√©e au module 5 : **/web2/tutorials/pizzeria/api/fat-model** ou via le code de ce web repo si vous avez un souci [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Il vous reste aussi √† vous assurer que votre frontend (**/web2/tutorials/pizzeria/hmi/basic-fetch**) est lui aussi bien d√©marr√©. Il devrait toujours y avoir l'erreur associ√©es aux **CORS** donn√©e au sein de la console.

Nous allons mettre en place un m√©canisme au niveau du frontend pour faire passer toutes les requ√™tes √† destination de l'API par un proxy ; le proxy aura la m√™me origine que le serveur de fichiers statiques ayant offert le frontend.

Voici le workflow que nous allons appliquer √† notre site g√©rant la pizzeria :

<ScrollableImage name="proxy.png" minWidth="691px" maxWidth="691px" />
<figcaption>Redirections des requ√™tes via un proxy</figcaption>

Gr√¢ce √† ce diagramme, on voit comment mettre √† jour le tutoriel pr√©c√©dent qui affichait une erreur au niveau des **CORS** : on va faire une requ√™te GET vers **/api/pizzas** et non plus vers **http://localhost:3000/pizzas**.

Pour cela, nous avons besoin d'un proxy. Et bien √ßa tombe bien, le serveur de d√©veloppement de Webpack met √† disposition un proxy. Celui-ci est d'ailleurs configur√© ainsi dans le boilerplate (voir fichier **./webpack.config.js**) :

```js
proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
```

Cela signifie qu'√† chaque fois qu'une requ√™te sera faite sur **/api** (on reste sur la m√™me origine que le serveur de fichiers statiques, **8080** tel que configur√© dans **./webpack.config.js** du boilerplate), celle-ci sera redirig√©e vers le port **3000**, le port de l'API.
Le **pathRewrite** permet de ne pas reprendre **/api** dans l'URL de la redirection : 
**GET /api/pizzas** devient **GET http://localhost:3000/pizzas**.

Dans le code du tutoriel en cours (**basic-fetch**), veuillez mettre √† jour l'URL au niveau du **fetch** dans **HomePage.js** :
```js numbered {4}
const HomePage = () => {
  clearPage();

  fetch('/api/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
      attachOnMouseEventsToGoGreen();
      renderDrinksFromNodes(DRINKS);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });
};
```

N'oubliez pas que votre API (**fat-model**) doit √™tre ex√©cut√©e, tout comme votre frontend (**basic-fetch**).

A ce stade-ci, l√† aussi, tout devrait fonctionner, le menu des pizzas est affich√© suite √† l'appel √† notre RESTful API ne relaxant pas la s√©curit√© !

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**hmi-proxy**".

En cas de souci, vous pouvez utiliser le code du tutoriel :
- pour le frontend : [basic-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).
- pour l'API : [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

üç¨ Voici quelques infos non capitales pour ce cours-ci :
- Il existe une multitude de proxy pour un environnement de d√©veloppement : **Webpack devServer** et son proxy, **VS Code proxy**, proxy l√©ger de **Node** directement configurable via **package.json** (`"proxy":¬†"http://localhost:3000",`), ... 
- Il existe par exemple un proxy complet sous Node : **http-proxy-middleware**.
- Pour la production, lorsque vous d√©ployer une application web sur le cloud, il faudra trouver les instructions de votre provider pour voir comment configurer le proxy.  
Par exemple, pour configurer un **static file server** et son **proxy** sous **heroku** (provider de services d'h√©bergements sur le cloud), il faut configurer le fichier **/static.json**.

üí≠ Que pensez-vous du code associ√© aux t√¢ches asynchrones, afin de cha√Æner des actions suite au **fetch** ?  
Ca n'est pas des plus lisibles... imaginez que vous avez des tonnes de **.then()**, dans lesquels vous allez aussi faire appel √† des fonctions asynchrones... Ca deviendra vite compliqu√© comme code.

Nous allons donc voir comment rendre la programmation asynchrone, √† l'aide de promesses, plus l√©g√®re, en utilisant **async** / **await**.

# <a id="d"></a> d) Programmation asynchrone √† l'aide de promesses & async / await
