---
title: "JWT auths API"
description: "Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT"
---

# a) Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part4"> Partie 4 </PathViewerItem>
    <PathViewerItem selected> a) JWT auths & API </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> C'est quoi l'authentification et l'autorisation ? </InternalPageMenuItem>
  <InternalPageMenuItem> Stateful VS stateless authentication </InternalPageMenuItem>
  <InternalPageMenuItem> C'est quoi les tokens JWT ? </InternalPageMenuItem>
  <InternalPageMenuItem> Authentification et cr√©ation de token </InternalPageMenuItem>
  <InternalPageMenuItem> Autorisation et v√©rification de token </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST avec JWT </InternalPageMenuItem>
  <InternalPageMenuItem> Protection des op√©rations d'√©criture d'une API </InternalPageMenuItem>
  <InternalPageMenuItem> Project 4.1 : Authentification & autorisation d'op√©rations </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> C'est quoi l'authentification et l'autorisation ? </InternalPageTitle>

## Authentification, c'est quoi ?
L'authentification, c'est le processus de **v√©rifier qui est l'utilisateur** d'une application.

Pour authentifier un utilisateur, on va g√©n√©ralement passer via un formulaire de connexion, lui demandant un username et un password.

## Autorisation, c'est quoi ?
L'autorisation, c'est le processus de **v√©rifier ce √† quoi un utilisateur √† acc√®s**.

Une API va autoriser les acc√®s √† certaines op√©rations en fonction des privil√®ges associ√©s aux utilisateurs. Il y aura des op√©rations qui seront autoris√©es : 
- **pour tous les utilisateurs**, tant anonymes qu'authentifi√©s ;  
*imaginez par exemple les op√©rations de lecture de produits sur un site "vitrine". Il ne faut pas devoir cr√©er de compte utilisateur pour pouvoir afficher les produits du site.*
- **pour tous les utilisateurs authentifi√©s**, peu importe leurs privil√®ges ;  
*imaginez le fait de pouvoir poster des messages dans un forum ; il faut avoir un compte pour pouvoir le faire, mais il ne faut pas de privil√®ges sp√©cifiques (pas besoin d'√™tre admin).*
- **pour seulement un ou plusieurs utilisateur(s) authentifi√©(s)** ayant les privil√®ges requis ;  
*imaginez une op√©ration de lecture de tous les profils des utilisateurs d'une banque ; il faut avoir un compte admin de la banque pour pouvoir le faire. Ca serait catastrophique si n'importe quel utilisateur authentifi√© pourrait acc√©der aux profils de tous les utilisateurs !*

## Diff√©rents moyens d'authentification

### Authentification stateful

Traditionnellement, ou anciennement, nous avons l'authentification qui est support√©e √† l'aide de cookies. L'utilisateur envoie via un formulaire son username et password, le serveur v√©rifie ceux-ci et cr√©e un id de session et le renvoie √† l'utilisateur via un cookie.  
Apr√®s l'authentification, √† chaque requ√™te du client sur ce serveur, le cookie est envoy√©, et le serveur, qui a sauvegard√© la session, va la retrouver sur base de l'id de session pr√©sent dans le cookie et va autoriser ou non l'acc√®s √† l'op√©ration demand√©e par le client.  
C'est ce qu'on appelle une authentification **stateful**.

Un m√©canisme d'authentification **stateful** indique que le serveur est responsable de sauvegarder les donn√©es de session des utilisateurs. 

On parle de **session** d'un utilisateur comme √©tant toute la dur√©e o√π le client s'authentifie √† l'application web jusqu'√† ce qu'il quitte cette application, lorsqu'il ferme son browser.

### Authentification stateless 

De mani√®re plus moderne, nous avons des m√©canismes d'authentification qui sont dits **stateless**. Dans ce genre de m√©canisme, c'est le client qui doit sauvegarder les donn√©es de session, et donc le browser. L'authentification √† l'aide de **tokens** devient tr√®s populaire.  
Il existe diff√©rents moyen de l'impl√©menter. Dans le cadre de ce cours, nous focuserons sur la fa√ßon la plus habituelle, les **JSON Web Tokens**, ou **JWT**.

Il existe d'autres m√©canismes tr√®s modernes qui utilisent des tokens, et qui sont mis en place par des tiers : **OAuth**, **OpenId**... Ces m√©canismes sont offerts par Microsoft, Google, Facebook... Nous ne les verrons pas dans le cadre de cours. N√©anmoins, √† la fin de ce cours, vous devriez √™tre apte √† pouvoir les utiliser, sous r√©serve de bien lire la documentation üòâ.

# <InternalPageTitle> Stateful VS stateless authentication  </InternalPageTitle>

Quels sont les avantages & inconv√©nients d'une authentification stateful ? et d'une authentification stateless ?

#### Authentification stateful
**Inconv√©nients** :
- La session utilise de la m√©moire pour chaque utilisateur.
- Le backend n'a aucune mani√®re de d√©terminer si le frontend s'est d√©connect√© du site ou non : gestion de l'expiration d'une session plus compliqu√©e, notamment si le frontend revient apr√®s une longue dur√©e.
- Toutes les sessions sont perdues en cas de red√©marrage du serveur (r√©authentification).
- Load balancing compliqu√© ; en effet, si un client fait une requ√™te, pendant toute la dur√©e de la session, s'il y a plusieurs serveurs qui peuvent y r√©pondre, comment est g√©r√©e la session de ce client ? Par quel(s) serveur(s) ? Comment se partagent-ils les donn√©es de session ? Est-ce que √ßa doit toujours √™tre le m√™me serveur qui r√©ponde au m√™me client ?

**Avantages** :
- Peu gourmand en ressource point de vue processing et tr√®s rapide ; en effet, une fois qu'une session est en place, la v√©rification que le cookie contient le bon id de session se fait vite.

#### Authentification stateless
**Inconv√©nients** : 
Comme le serveur ne retient plus l'utilisateur en m√©moire, il doit utiliser de la cryptographie pour cr√©er et valider les token ; c'est donc consommateur en ressource point de vue processing.

**Avantages** : 
- Pas de session √† g√©rer, m√™me apr√®s red√©marrage du serveur, il n'y a pas de r√©authentification n√©cessaire.
- Evolutif, utilisation facile de plusieurs serveurs si du load balancing est n√©cessaire ; en effet, comme chaque requ√™te du client contient toutes les infos pour se faire autoriser, il n'est pas n√©cessaire de savoir quel serveur va prendre en charge la requ√™te.

Notons que la "scalability" horizontale, la possibilit√© de permettre √† une application d'augmenter sa capacit√© de r√©pondre √† une charge grandissante simplement en ajoutant des machines, est quelque chose de tr√®s important √† notre √©poque.  
Certaines applications web ont des centaines de millions d'utilisateurs ; pour celles-ci, on ne peut pas compter sur la "scalability" verticale, c'est-√†-dire le fait d'augmenter les ressources d'une machine, en augmentant sa RAM, son processeur, son espace de stockage...

D√®s lors, dans le cadre de ce cours, nous allons pr√©f√©rer les applications web qui peuvent tourner sur des serveurs **stateless**.

# <InternalPageTitle> C'est quoi les tokens JWT ? </InternalPageTitle>

Les **JSON Web token**, ou **JWT**, appartiennent √† un standard internet permettant l'√©change s√©curis√© de tokens entre plusieurs parties.

Un **JWT** contient **trois parties encod√©es en base64** et ressemble √† qqch du style :  
**`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.`**  
**`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.`**   
**`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`**

Voici les 3 parties d'un JWT et leurs caract√©ristiques :
- l'**ent√™te** (ou header) : un objet JSON identifiant le type de token (JWT) et l'algorithme utilis√© pour g√©n√©rer la signature du token (HS256), un algorithme de hachage. 
- le **payload** : un objet JSON permettant de sp√©cifier le **claim** ; ce sont des param√®tres optionnels pr√©cisant les affirmations associ√©es au token, comme la date d'expiration du token, son cr√©ateur, le fait que l'utilisateur est admin... g√©n√©ralement, on y met pas trop d'info, principalement l'identifiant de l'utilisateur ; si l'API a besoin de plus d'info concernant l'utilisateur, elle ira g√©n√©ralement les chercher dans ses donn√©es.
- la **signature** : c'est une signature num√©rique construite √† partir d'un secret priv√© ou d'une cl√© publique/priv√©e, via l'algorithme pr√©cis√© dans la signature.

üí≠ C'est bien joli tout √ßa, mais comment √ßa permet de s√©curiser la session d'un utilisateur ?  
G√©n√©ralement, l'API, et elle uniquement, connait le secret priv√©. Elle va donc cr√©er le token d'un utilisateur authentifi√©, en y ajoutant le claim (ou les affirmations) qu'elle juge utile.  
Lorsque le client re√ßoit son token, il va le sauvegarder dans son browser.  
Pour chaque requ√™te n√©cessitant une autorisation de l'API, le client enverra son token au sein du header de la requ√™te.  
L'API utilisera le secret priv√©, connu d'elle-m√™me uniquement, pour v√©rifier la signature du token. Si tout est OK, c'est que l'utilisateur est bien authentifi√© et que son claim est OK.

Imaginez maintenant qu'un hackeur tente de modifier le token, pour modifier le claim, notamment en changeant l'id de l'utilisateur pr√©sent dans le payload du token.
Et bien la signature ne correspondra plus √† ce token l√† ! L'API le d√©tectera.  
Pour que le hackeur r√©ussisse son acte malicieux, il est oblig√© de conna√Ætre le secret priv√© qui ne doit √™tre connu que de l'API. Ca ne serait que sur base du secret priv√© que les hackeurs pourraient g√©n√©rer un nouveau token qui serait valid√© par l'API. Pas √©vident √† faire...

Ainsi, on peut imaginer un token comme une enveloppe s√©curis√© par un cadenas tr√®s sp√©cial : ce cadenas, qui est mis sur l'enveloppe contenant, par exemple, l'identifiant d'un utilisateur, est ferm√© par la cl√© üîë que seulement conna√Æt l'API.
Si quelqu'un touche √† l'enveloppe, le cadenas ne s'ouvrira plus avec la üîë de l'API : la tentative de hackage sera d√©tect√©e ! 
Si quelqu'un tente de cr√©er une enveloppe s√©curis√©, il le fera avec une autre cl√©, **üóù** par exemple, car il ne conna√Æt pas üîë. L'API, tentant d'ouvrir l'enveloppe s√©curis√©e √† l'aide de üîë, elle ne s'ouvrira pas : la tentative de hacking sera d√©tect√©e ! 

üí≠ Est-ce que cette m√©taphore d'enveloppe s√©curis√©e vous parle ?
Attention que dans la r√©alit√©, le payload classique d'un token sera d√©codable, que l'on connaisse ou pas le secret priv√©. Il est encod√© en base64 ! Ne mettez donc jamais de secrets dans le payload d'un token !  
Si vraiment un jour vous deviez mettre un secret dans un payload, bien que d√©conseill√©, vous pourriez toujours le faire en cryptant le payload.

üëç Le m√©canisme de token assure que l'on aie une tr√®s haute probabilit√© de d√©tecter les alt√©rations faites sur les tokens, les tentatives de forgeage, gr√¢ce √† la signature de ceux-ci.  

‚ö° Par contre, si nous laissions tra√Æner des informations dans le payload d'un token, comme un password d'un utilisateur et son username, alors l√†, c'est juste un beau cadeau que l'on offre aux hackeurs ; ils n'auraient plus qu'√† trouver un moyen de voler √† distance nos donn√©es de session ; ils pourraient ensuite utiliser le formulaire de connexion et prendre possession de notre identit√© üò®.

Il existe un site fort int√©ressant qui montre la structure d'un token et qui permet de les d√©coder : [jwt.io](https://jwt.io/) [[R.63]](/references/#r63). Nous l'utiliserons plus tard pour d√©coder les tokens g√©n√©r√©s par nos RESTful API.

# <InternalPageTitle> Authentification et cr√©ation de token </InternalPageTitle>

## Introduction

Via un exemple concret associ√© √† notre RESTful API qui g√®re les ressources de type "pizzas", nous allons mettre en place un processus d'authentification et d'autorisation JWT.

La librairie que nous allons utiliser dans le cadre de ce cours pour g√©rer des tokens JWT est [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken).

Dans ce nouveau tutoriel, nous allons continuer le d√©veloppement de l'API [api-fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model) pour ajouter des op√©rations permettant l'authentification et l'autorisation d'utilisateurs.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/api/auths`** sur base d'un copi√© coll√© de **`/web2/tutorials/pizzeria/api/fat-model`** (ou [api-fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/api/auths`**.

Veuillez installer la librairie **`jsonwebtoken`** au sein de votre nouveau projet **`auths`** :
```bash
npm i jsonwebtoken
```

## M√©canisme d'authentification et cr√©ation du token

Toujours √† l'aide d'Express, nous allons cr√©er un router **`auths`** qui mettra √† disposition les op√©rations de **`login`** et de **`register`**. 
Voici le contrat associ√© √† ces nouvelles op√©rations :

##### Op√©rations sur les ressources de type "auths"
| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`auths/login`** | **POST** | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |
| **`auths/register`** | **POST** | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |

<br/>

Le mod√®le **`users`** s'occupera de cr√©er les utilisateur, de v√©rifier leurs credentials ainsi que de cr√©er des token.

Voici le workflow attendu pour une op√©ration de **`login`** ou de **`register`** :

<ScrollableImage name="login.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une RESTful API pour s'authentifier et obtenir un JWT</figcaption>

Ce que l'on voit dans l'image ci-dessus : 
- si le mod√®le consid√®re que l'utilisateur est authentifiable, que ses credentials sont OK, alors il va utiliser la m√©thode **`sign`** de l'objet **`jwt`** pour cr√©er un token. 
- le token est envoy√© dans le body de la r√©ponse √† l'utilisateur. 

Ce que l'on ne voit pas dans l'image ci-dessus :
- c'est le job du client de sauvegarder le token. Si l'application cliente est un browser, alors celui-ci pourra √™tre sauvegard√© dans le web storage du browser.
- l'application cliente peut √™tre faite avec n'importe quelle technologie. Par exemple, nous pourrons utiliser REST Client pour faire une requ√™te √† l'API...

Dans notre RESTful API, nous avons d√©cid√© que lorsqu'un client s'enregistre, quand il fait appel √† l'op√©ration **`register`** pour cr√©er un compte, l'API consid√®re automatiquement que cet utilisateur est authentifi√©. Tout comme la m√©thode **`login`**, la m√©thode **`register`** cr√©era et renverra un token JWT √† l'utilisateur.

NB : Il est possible d'envisager un workflow diff√©rent : apr√®s le **`register`**, l'application demanderait √† l'utilisateur un **`login`**, **`register`** ne renvoyant jamais de token √† l'utilisateur.

## Impl√©mentation de login & register

Nous allons √† pr√©sent mettre en place le code permettant d'impl√©menter le workflow que l'on vient de d√©couvrir.

Veuillez cr√©er le mod√®le **`users`** en cr√©ant le fichier **`/models/users.js`** et y inclure ce code :
```js numbered highlighting="1,5-6,23-27,29-31,34,43-47,49-52,54"
const jwt = require('jsonwebtoken');
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jwtSecret = 'ilovemypizza!';
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const jsonDbPath = path.join(__dirname, '/../data/users.json');

const defaultUsers = [
  {
    id: 1,
    username: 'admin',
    password: 'admin',
  },
];

function login(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;
  if (userFound.password !== password) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function register(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username) {
  const users = parse(jsonDbPath, defaultUsers);
  const indexOfUserFound = users.findIndex((user) => user.username === username);
  if (indexOfUserFound < 0) return undefined;

  return users[indexOfUserFound];
}

function createOneUser(username, password) {
  const users = parse(jsonDbPath, defaultUsers);

  const createdUser = {
    id: getNextId(),
    username,
    password,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

function getNextId() {
  const users = parse(jsonDbPath, defaultUsers);
  const lastItemIndex = users?.length !== 0 ? users.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = users[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

module.exports = {
  login,
  register,
  readOneUserFromUsername,
};

```

Dans le code ci-dessus, **jwtSecret** est le secret priv√© connu uniquement du serveur. C'est la m√™me secret qu'il faudra utiliser pour v√©rifier un token.  

**`jwt.sign()`** permet de cr√©er le token et ses 3 parties :
- le payload du token, la 2√®me partie du token, est compl√©t√© principalement via le permier argument de **`sign()`** ; ici, le token affirme que l'utilisateur poss√©dant le **`username`** donn√© est authentifi√©.
- le payload du token sera aussi modifi√© sur base de la dur√©e d'expiration du token, selon l'argument **`expiresIn`**.
- **`jwtSecret`** est utilis√© pour cr√©er la 3√®me partie du token, sa signature.

Il faut maintenant que nous cr√©ions le router **`auths`** offrant les op√©rations de **`login`** et de **`register`**, en faisant appel au mod√®le **`users`**.  
Veuillez cr√©er le fichier **`/routes/auths.js`** et y inclure le code suivant :
```js
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  return res.json(authenticatedUser);
});

/* Login a user */
router.post('/login', (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  return res.json(authenticatedUser);
});

module.exports = router;
```

Il n'y a rien de bien sp√©cial √† ce code. On fait simplement appel aux op√©rations du mod√®le **`users`**.

Attention, il faut rajouter le nouveau router au sein de **`app.js`** pour que notre API puisse offrir les nouvelles op√©rations ; veuillez donc ajouter ce code dans **`/app.js`** :
```js highlighting="7,18"
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');
const authsRouter = require('./routes/auths');

const app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', pizzaRouter);
app.use('/auths', authsRouter);

module.exports = app;
```

## Utilisation de Rest Client pour tester les nouvelles op√©rations

Veuillez d√©marrer votre API **`auths`**.

On va utiliser REST Client pour tester ces nouvelles op√©rations.

Veuillez cr√©er le fichier **`/REST Client/auths.http`** et y ajouter le code suivant :
```http
@baseUrl = http://localhost:3000

### Try to login an unknow user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"unknown",
    "password":"admin"
}

### Login the default admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}


### Create the manager user
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

### Login the manager user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}
```

Veuillez ex√©cuter les diff√©rentes requ√™tes. Tout devrait fonctionner, vous devriez r√©cup√©rer le username et le token d'un utilisateur authentifi√©.

Pour le fun, nous allons d√©coder un token : 
- Veuillez copier le token de ce que renvoie votre API pour la requ√™te de login de l'utilisateur **`manager`** (qqch qui doit ressembler √† une string du genre : **`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjEyNDg1MjksImV4cCI6MTc0NzY0ODUyOX0.JvYzM0gtmVkqFr9R3f1Bf6ow_QuyHJY-vedJ39N7JKw`**).
- Veuillez vous rendre sur le site [JWT](https://jwt.io/) et coller votre token dans le champs **`Encoded`**. Dans la colonne **`Decoded`**, vous devriez voir l'algorithme utilis√© par la m√©thode **`sign`**, ainsi que les donn√©es pr√©sentes dans le payload, dont **`"username": "manager"`** ! 

Vous comprenez maintenant pourquoi on n'ajoute pas des secrets dans un token üòâ.

## Cacher ses secrets

Dans ce cours-ci, vous pouvez, de mani√®re optionnelle, voir comment faire en sorte que le secret,  permettant de signer & v√©rifier les token, ne soit pas pr√©sent sur le web repository de vos API (par exemple ici le mod√®le **`users.js`** hardcode ce secret). En effet, pour des raisons de s√©curit√©, si votre secret est visible pour tous les d√©veloppeurs qui acc√®de √† votre repository public, c'est un probl√®me !

Si vous souhaitez d√©couvrir comment faire en sorte de rendre invisible des informations sensibles sur un web repository, tout en pouvant b√©n√©ficiant de ces infos dans votre environnement de d√©veloppement, vous pouvez consulter la partie 3 du cours sur la [Protection de ses secrets](../../part3/#üç¨_protection_de_ses_secrets).

# <InternalPageTitle> Autorisation et v√©rification de token </InternalPageTitle>

## M√©canisme d'autorisation d'utilisateurs √† des op√©rations d'une API 

### Intro

Dans le workflow que nous avons choisi, les utilisateurs re√ßoivent un token lors du **`register`** ou du **`login`**. C'est le job de l'application cliente de trouver un moyen de sauvegarder ce token. 

Lorsqu'une application client souhaite cr√©er une pizza, on souhaite autoriser cette op√©ration qu'√† l'administrateur du site g√©rant la pizz√©ria.  
Nous d√©cidons donc pour l'**op√©ration de cr√©ation de pizza que l'utilisateur doit** non seulement √™tre **authentifi√©**, mais qu'en plus, il doit √™tre l'**admin** du site.

### M√©canisme d'autorisation quand le token JWT est valide

Pour que l'application client qui fait la requ√™te √† l'API puisse s'autoriser, elle doit ajouter un **`authorization header`** √† sa requ√™te contenant comme valeur le token re√ßu lors du **`login`** ou du **`register`** :

<ScrollableImage name="authorizeOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation valide</figcaption>

Le router de "pizzas", avant m√™me de passer la requ√™te √† la route **`POST /pizzas`**, va lancer la fonction middleware d'autorisation nomm√©e **`authorize`**. La fonction middleware **`authorize`** va s'occuper de v√©rifier le token envoy√© par le client dans un header √† l'aide de la m√©thode **`verifiy`** de l'objet **`jwt`** (de la librairie **`jsonwebtoken`**).

üí≠ Si le token est valide, est-ce que √ßa signifie que l'utilisateur est bien authentifi√© ?  
*H√© bien non, car imaginez qu'entre le moment o√π l'utilisateur se soit logu√©, il ait √©t√© supprim√© de l'application par un admin... dans ce cas-ci, on ne veut pas l'autoriser √† ajouter une pizza au menu de la pizzeria ! Il n'est p-e m√™me plus un employ√©, il souhaite p-e √©crire du contenu malicieux üò®*

Donc si le token est valide, **`authorize`** fera appel au mod√®le de **`users`** pour v√©rifier que l'utilisateur existe bien dans le support de donn√©es (fichiers JSON, base de donn√©es ou autres) et pour obtenir toutes les infos sur cet utilisateur. Si l'utilisateur existe, alors cela signifie que l'utilisateur est bien authentifi√©. La fonction middleware **`authorize`** va passer la main √† une autre fonction middleware pour v√©rifier que l'utilisateur est bien l'admin.

üí≠ Comment est-ce que **`authorize`** peut faire appel au mod√®le pour v√©rifier que l'utilisateur existe bien ? Est-ce que cela signifie que le token doit contenir tout un tas de donn√©es sur l'utilisateur ?

üëç En r√®gle g√©n√©rale, on va juste mettre un identifiant de l'utilisateur dans ce qu'on appelle le **payload** du token. C'est ensuite l'API, suite au d√©codage de l'identifiant de l'utilisateur, qui fera appel aux donn√©es pour retrouver tout ce qui concerne l'utilisateur.

La fonction middleware **`isAdmin`** va v√©rifier que l'utilisateur est bien l'admin. Si c'est OK, elle passera la main √† la fonction middleware qui g√®re la route **`POST /pizzas`** au sein du router de pizzas en faisant l'appel √† la fonction **`next`**.  
*üç¨ NB : on pourrait aussi laisser la fonction **`createOnePizza`** s'occuper de v√©rifier que l'utilisateur demandant la cr√©ation de la pizza soit bien l'admin. Ici, comme il s'agit de v√©rifier que le contrat de l'API soit respect√©, c'est-√†-dire que l'utilisateur soit bien authentifi√© & admin, alors on pr√©f√®re r√©aliser cette action en dehors du mod√®le. Dans nos choix architecturaux pour nos RESTful API, nous avons d√©cid√© que ce n'est pas le mod√®le qui s'occupe de pr√©senter les donn√©es aux clients, c'est le r√¥le des routers (et les fonctions middleware associ√©es).*

Maintenant que le client a les bons privil√®ges, l'op√©ration de cr√©ation de la pizza peut donc √™tre autoris√©e. L'op√©ration de **`createOnePizza`** du mod√®le renverra la nouvelle pizza au router qui s'occupera de pr√©senter la nouvelle pizza au client, au format JSON.

### M√©canisme d'autorisation quand le token JWT est invalide

Voici le workflow d'autorisation si le token n'est pas valide :

<ScrollableImage name="authorizeNOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation invalide</figcaption>

Dans ce cas l√†, **`authorize`** ne passe pas la main √† **`isAdmin`** ni m√™me √† la fonction middleware qui g√®re la route **`POST /pizzas`**.  
La fonction middleware **`authorize`** renvoie directement un code d'erreur **`401 Unauthorized`** au client. 

### M√©canisme d'autorisation quand l'utilisateur n'est pas admin

Vous pourriez aussi imaginer le workflow o√π le client envoie un token valide, mais l'utilisateur associ√© n'est pas admin. Dans ce cas-ci, **`authorize`** ferait appel √† **`isAdmin`**, mais **`isAdmin`** renverrait directement un code d'erreur **`403 Forbidden`** au client.  
En effet, l'API indiquerait ainsi qu'elle aurait v√©rifi√© que l'utilisateur est bien authentifi√©, mais que celui ne poss√®de pas les privil√®ges suffisant pour acc√©der √† l'op√©ration demand√©e.

## Impl√©mentation du m√©canisme d'autorisation

üò® Wow, le workflow d'autorisation pour la cr√©ation d'une pizza est assez long.  
Nous allons maintenant l'impl√©menter dans notre tutoriel en cours.  
Nous vous inqui√©tez pas, ce qui importe dans le code qui va suivre, ce n'est pas de savoir √©crire tout le code, mais de bien comprendre les m√©canismes associ√©s. En effet, en r√®gle g√©n√©rale, vous allez utiliser des librairies vous permettant d'autoriser les acc√®s aux op√©rations de vos API. Vous √©crirez donc rarement les m√©canismes d'autorisation, par contre, vous devrez pouvoir les utiliser.

Veuillez cr√©er les nouvelles fonctions middleware **`authorize`** et **`isAdmin`** au sein d'un nouveau fichier **`/utils/auths.js`** :
```js numbered highlighting="1,4,7,11-12,18"
const jwt = require('jsonwebtoken');
const { readOneUserFromUsername } = require('../models/users');

const jwtSecret = 'ilovemypizza!';

const authorize = (req, res, next) => {
  const token = req.get('authorization');
  if (!token) return res.sendStatus(401);

  try {
    const decoded = jwt.verify(token, jwtSecret);
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) return res.sendStatus(401);

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error('authorize: ', err);
    return res.sendStatus(401);
  }
};

const isAdmin = (req, res, next) => {
  const { username } = req.user;

  if (username !== 'admin') return res.sendStatus(403);
  return next();
};

module.exports = { authorize, isAdmin };
```

Voici quelques explications sur le code de la fonction middleware **`authorize`** : 
- Gr√¢ce √† **`req.get('authorization')`** (ligne 7), on r√©cup√®re le token qui a √©t√© envoy√© par le client au sein de l'**`authorization header`** de la requ√™te sous forme de string.
- La m√©thode **`jwt.verify(token, jwtSecret)`** (ligne 11) v√©rifie tant la signature du token que son √©ventuelle expiration. Elle utilise le secret **`jwtSecret`** qui doit √™tre le m√™me que celui pris en compte lors de la cr√©ation du token.
- Elle charge toutes les donn√©es de l'utilisateur authentifi√© au sein de l'objet **`req`** (ligne 18), dans **`user`**. Cela est une bonne pratique, cela permet, pour toute la dur√©e du traitement de cette requ√™te, de mettre √† disposition ces donn√©es √† toutes les fonctions middleware.    
üí≠ Mais pourquoi faire cela ?
*Imaginez que vous faites un appel √† une base de donn√©es externes √† chaque fois que vous souhaitez obtenir les informations d'un utilisateur... Cela est tr√®s consommateur en temps... Lorsque vous allez utiliser d'autres fonctions middleware comme **`isAdmin`**, vous n'avez plus besoin de faire appel √† la base de donn√©es.*

La fonction middleware **`isAdmin`** r√©cup√®re les donn√©es de l'utilisateur authentifi√© via l'objet **`req.user`**.  
Si l'utilisateur n'est pas **`admin`**, c'est le code **`403 Forbidden`** qui est renvoy√© √† l'application cliente, signifiant que l'utilisateur est bien authentifi√©, mais il n'a pas les privil√®ges pour acc√©der √† l'op√©ration demand√©e (cr√©ation de pizza).  
Si tout est OK, **`isAdmin`** fait appel √† **`next()`**, ce qui consiste √† ex√©cuter la prochaine fonction middleware qui est pr√©sente apr√®s l'appel de **`isAdmin`**.

O√π allons-nous utiliser ces nouvelles fonctions middleware ?

Nous pouvons le faire au niveau que nous souhaitons, soit au niveau :
- de l'**application**, pour toutes les routes, via **`app.use(authorize)`**.
- d'un **router**, pour toutes les routes associ√©es ; par exemple, on pourrait dire que toutes les routes du router de pizzas sont prot√©g√©es par une autorisation JWT. On √©crirait : **`app.use("/pizzas", authorize, pizzaRouter);`**.  
Cela signifierait que toutes les op√©rations sur des ressources de type "pizzas" ne seraient autoris√©es que si l'utilisateur √©tait authentifi√©. Cela serait probl√©matique pour deux raisons :
    - On veut pouvoir afficher le menu des pizzas pour tous les utilisateurs, m√™me s'ils sont anonymes.
    - On ne veut pas simplement v√©rifier qu'un utilisateur est authentifi√© pour cr√©er une pizza, on veut aussi v√©rifier qu'il est admin.
- d'une route, pour une op√©ration de notre RESTful API. C'est ce que nous souhaitons faire ici. Veuillez mettre √† jour le code du router de "pizzas" au sein de **`/routes/pizzas.js`** :
```js highlighting="2,7"
// See existing code
const { authorize, isAdmin } = require('../utils/auths');

// See existing code

// Create a pizza to be added to the menu.
router.post('/', authorize, isAdmin, (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const createdPizza = createOnePizza(title, content);

  return res.json(createdPizza);
});
```

Ainsi, nous avons juste fait l'appel de deux fonctions middleware pour v√©rifier :
- **que l'utilisateur est authentifi√©** via **`authorize`** ; si tout est OK au niveau du token fournit par l'application cliente, **`authorize`** fait appel via **`next()`** √† la prochaine fonction middleware. Dans ce cas-ci, c'est **`isAdmin`**. S'il y a un probl√®me, **`authorize`** termine le traitement de la requ√™te en envoyant un code d'erreur au client et les prochaines fonctions middleware (**`isAdmin`**, puis la fonction **`arrow`**) ne sont pas ex√©cut√©es.
- **que l'utilisateur est admin** via **`isAdmin`** ; si tout est OK, que l'utilisateur authentifi√© est l'admin, **`isAdmin`** fait appel via **`next()`** √† la prochaine fonction middleware. Dans ce cas-ci, c'est la fonction **`arrow`** qui appelle l'op√©ration demand√©e pour cr√©er la pizza : **`createOnePizza`**. Si l'utilisateur authentifi√© n'est pas l'admin, alors **`isAdmin`** termine le traitement en envoyant un code d'erreur au client et la fonction traitant de l'op√©ration de cr√©ation n'est pas ex√©cut√©e.

Comment pouvons-nous tester l'op√©ration de cr√©ation d'une pizza ? Via REST Client.
Tentons le coup √† l'aide de cette requ√™te (elle est d√©j√† pr√©sente dans **/REST Client/pizzas.http**) :
```http
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Apr√®s avoir ex√©cut√© cette requ√™te, vous devriez avoir re√ßu un status code **`401 Unauthorized`**.
C'est normal, comme nous n'avons pas envoy√© de token, nous ne pouvons donc pas √™tre autoris√©.  
Au prochain point nous allons voir comment utiliser REST Client pour sauvegarder de l'information, comme un token, suite √† une requ√™te vers une API.

# <InternalPageTitle> Client REST avec JWT </InternalPageTitle>

Pr√©c√©demment, nous avons appris √† utiliser REST Client, l'extension de VS Code, pour faire des requ√™tes vers des API.

Voici quelques notions suppl√©mentaire pour utiliser REST Client avec des **`JWT`** :
- Il est possible de cr√©er des **`Request Variables`** afin de **r√©cup√©rer la r√©ponse** associ√©e 
√† une requ√™te au sein d'une variable.
- On va donc pouvoir r√©cup√©rer le token, suite √† une requ√™te d'authentification, 
au sein d'une **`Request Variable`**, pour ensuite fournir ce token dans le **`Authorization header`** de toutes les requ√™tes demandant une autorisation JWT.

Si vous souhaitez plus d'infos sur les **`Request Variables`**, vous pouvez consulter la [documentation de REST Client](https://github.com/Huachao/vscode-restclient#request-variables) [[R.55]](/references/#r55).

Voici comment mettre √† jour le script **`/REST Client/pizzas.http`** pour cr√©er une pizza en passant le token de l'utilisateur **`admin`** :

```http
### Create a pizza by using the admin account
#### First login as the admin
##### Define a request variable nammed admin :
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Pour tester l'op√©ration de cr√©ation de pizza, veuillez d'abord ex√©cuter la premi√®re requ√™te, puis la seconde donn√©e ci-dessus.

A ce stade-ci, il serait aussi int√©ressant de tester certains cas d'erreurs associ√©s aux tokens. Veuillez compl√©ter le script **`/REST Client/pizzas.http`** avec :
```http
### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
##### 2.1.1 Define a request variable nammed manager
# @name manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

##### 2.1.2 Define a file variable to simplify the access to the token of manager
@managerToken = {{manager.response.body.token}}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{managerToken}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Nous voyons qu'√† l'aide de REST Client, nous pouvons utiliser une **`File Variable`** pour allouer une partie de la r√©ponse faite √† une requ√™te.  
Dans ce cas, on peut faire appel √† l'API en passant le token via la **`File Variable`** nomm√© **`managerToken`** (code associ√© : **`Authorization: {{managerToken}}`**) au lieu d'utiliser une partie seulement de la **`Request Variable`** nomm√©e **`manager`** (code possible : **`Authorization: {{manager.response.body.token}}`**).  
Cela permet de cr√©er des requ√™tes plus concises.

# <InternalPageTitle> Protection des op√©rations d'√©criture d'une API </InternalPageTitle>

Veuillez mettre √† jour votre RESTful API g√©rant les pizzas afin que toutes les op√©rations d'√©criture soient prot√©g√©es par une autorisation JWT, n'autorisant que l'utilisateur **admin**.

Voici le code √† mettre √† jour dans **`/routes/pizzas`** pour correctement autoriser les op√©rations de suppression et de modification sur des ressources de type "pizzas":
```js highlighting="2,11"
// Delete a pizza from the menu based on its id
router.delete('/:id', authorize, isAdmin, (req, res) => {
  const deletedPizza = deleteOnePizza(req.params.id);

  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', authorize, isAdmin, (req, res) => {
  const title = req?.body?.title;
  const content = req?.body?.content;

  if ((!title && !content) || title?.length === 0 || content?.length === 0) {
    return res.sendStatus(400);
  }

  const updatedPizza = updateOnePizza(req.params.id, { title, content });

  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});
```

Pour vous assurer que les op√©rations de suppression et de modification sont bien fonctionnelles, veuillez mettre √† jour les requ√™tes associ√©es afin d'utiliser un token. Veuillez mettre √† jour **`/REST Client/pizzas.http`** en ajoutant ces deux lignes :

```http numbered highlighting="25,30"
### Create a pizza by using the admin account
#### First login as the admin
##### Define a request variable nammed admin
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2
Authorization: {{admin.response.body.token}}

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cutez les requ√™tes de type **DELETE** et de type **PATCH** afin de vous assurer que l'API est en ordre.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message :
**`api auths tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel [api-auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

# <InternalPageTitle> Project 4.1 : Authentification & autorisation d'op√©rations </InternalPageTitle>

Vous devez mettre √† jour l'API d√©velopp√©e pour [Project 2.18](../../part2/comms-security/#project_2_18_autorisation_de_nouvelles_origines) afin de s√©curiser certaines op√©rations par JWT.

Le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/4.1/api`** sur base d'un copier/coller du code de [Project 2.18](../../part2/comms-security/#project_2_18_autorisation_de_nouvelles_origines).

Il est possible que dans le cadre de votre projet, vous n'ayez pas besoin d'authentifier des utilisateurs afin de prot√©ger l'acc√®s √† certaines op√©rations sur des ressources.

Si c'est le cas, il est quand m√™me important d'apprendre les concepts associ√©s √† l'authentification et √† l'autorisation JWT. Veuillez donc d√©velopper un prototype d'application qui n√©cessiterait une authentification, ainsi qu'au moins une op√©ration qui devrait √™tre autoris√©e.

Si vous n'avez pas d'id√©e, vous pourriez simplement d√©velopper un prototype permettant d'entrer des commentaires sur votre site web et de les visualiser.

Dans un premier temps, veuillez identifier toutes les op√©rations mises √† disposition par votre API, ainsi que si celles-ci sont prot√©g√©es par JWT, au sein du fichier **`README.md`** (fichier Markdown) de votre projet. Voici un exemple de comment nous vous recommandons de documenter votre API, sous forme de tableau : 

| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **`films`** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **`comments`** | GET | JWT | READ ALL FILTERED : Lire toutes les ressources de la collection |
| **`comments`** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| ... | ... | ... | ... |

<br/>

<AuthenticatedBlock>

Veuillez travailler avec les membres de votre groupe et vous partager le travail.

Un peu avant la fin de la s√©ance, veuillez discuter :
- du lien entre les UCs que vous avez identifi√©s en d√©but de projet et les op√©rations de votre API.
- des difficult√©s rencontr√©es, de ce que vous avez appris...

</AuthenticatedBlock>

Vous devez tester toutes les nouvelles op√©rations que vous prot√©gez par une autorisation JWT √† l'aide de Rest Client.

Quand un prototype d'api est finalis√© et test√©, veuillez faire un **`commit`** de votre code avec comme message : **`4.1 : api JWT auths`**.

#### ü§ù Tips
Comment cr√©er un tableau dans un fichier Markdown (pour **`README.md`**) ?  
Voici deux options :
- Soit vous utiliser des **`|`** pour d√©limiter les cellules et des **`|---|`** pour s√©parer 
les headers du corps du tableau. 
Voici le Markdown de l'exemple donn√© ci-dessus :
```text
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **`films`** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **`comments`** | GET | JWT | READ ALL FILTERED : Lire toutes les ressources de la collection |
| **`comments`** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| ... | ... | ... | ... |
```
- Soit c'est simplement un tableau HTML (`<table>`).

Comment ajouter l'authentification et l'autorisation JWT au sein de votre projet ?
- Soit vous partez du boilerplate du cours offrant l'authentification et l'autorisation JWT : [jwt-api-boilerplate](https://github.com/e-vinci/jwt-api-boilerplate). 
Puis vous pouvez y int√©grer le code d√©velopp√©e pour [Project 2.18](../../part2/comms-security/#project_2_18_autorisation_de_nouvelles_origines).
- Soit vous refaites les √©tapes du tutoriel dans cette page en partant du code d√©velopp√© pour [Project 2.18](../../part2/comms-security/#project_2_18_autorisation_de_nouvelles_origines).

# <InternalPageTitle> Project 4.22 : Authentification & autorisation d'op√©rations </InternalPageTitle>