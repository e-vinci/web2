---
title: "JWT auths API"
description: "Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part4"> Partie 4 </PathViewerItem>
    <PathViewerItem selected> a) JWT auths & API </PathViewerItem>
</PathViewer>

# a) Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT

<InternalPageMenu>
  <InternalPageMenuItem> C'est quoi l'authentification et l'autorisation ? </InternalPageMenuItem>
  <InternalPageMenuItem> Stateful VS stateless authentication </InternalPageMenuItem>
  <InternalPageMenuItem> C'est quoi les tokens JWT ? </InternalPageMenuItem>
  <InternalPageMenuItem> Authentification & autorisation stateless via JWT & Expres </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Cacher ses secrets </InternalPageMenuItem>
  <InternalPageMenuItem> M√©canisme d'autorisation et v√©rification du token </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST avec JWT </InternalPageMenuItem>
  <InternalPageMenuItem> Protection des op√©rations d'√©criture d'une API </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> C'est quoi l'authentification et l'autorisation ? </InternalPageTitle>

## Authentification, c'est quoi ?
L'authentification, c'est le processus de v√©rifier qui est l'utilisateur d'une application.

Pour authentifier un utilisateur, on va g√©n√©ralement passer via un formulaire de connexion, lui demandant un username et un password.

## Autorisation, c'est quoi ?
L'autorisation, c'est le processus de v√©rifier ce √† quoi un utilisateur √† acc√®s.

Une API va autoriser les acc√®s √† certaines op√©rations en fonction des privil√®ges associ√©s aux utilisateurs. Il y aura des op√©rations qui seront autoris√©es : 
- pour tous les utilisateurs, tant anonymes qu'authentifi√©s ; imaginez par exemple les op√©rations de lecture de produits sur un site "vitrine". Il ne faut pas devoir cr√©er de compte utilisateur pour pouvoir afficher les produits du site.
- pour tous les utilisateurs authentifi√©s, peu importe leurs privil√®ges ; imaginez le fait de pouvoir poster des messages dans un forum ; il faut avoir un compte pour pouvoir le faire, mais il ne faut pas de privil√®ges sp√©cifiques (pas besoin d'√™tre admin).
- pour seulement un ou plusieurs utilisateur(s) authentifi√©(s) ayant les privil√®ges requis ; imaginez une op√©ration de lecture de tous les profils des utilisateurs d'une banque ; il faut avoir un compte admin de la banque pour pouvoir le faire. Ca serait catastrophique si n'importe quel utilisateur authentifi√© pourrait acc√©der aux profils de tous les utilisateurs !

## Diff√©rents moyens d'authentification
Il existe de nombreux m√©canismes d'authentification.

Traditionnellement, ou anciennement, nous avons l'authentification qui est support√©e √† l'aide de cookies. L'utilisateur envoie via un formulaire son username et password, le serveur v√©rifie ceux-ci et cr√©e un id de session et le renvoie √† l'utilisateur via un cookie.  
Apr√®s l'authentification, √† chaque requ√™te du client sur ce serveur, le cookie est envoy√©, et le serveur, qui a sauvegard√© la session, va retrouver la session sur base de l'id de session pr√©sent dans le cookie et va autoriser ou non l'acc√®s √† l'op√©ration demand√©e par le client.  
C'est ce qu'on appelle une authentification **stateful**.

Un m√©canisme d'authentification **stateful** indique que le serveur est responsable de sauvegarder les donn√©es de session des utilisateurs. 

On parle de **session** d'un utilisateur comme √©tant toute la dur√©e o√π le client s'authentifie √† l'application web jusqu'√† ce qu'il quitte cette application, lorsqu'il ferme son browser.

De mani√®re plus moderne, nous avons des m√©canismes d'authentification qui sont dits **stateless**. Dans ce genre de m√©canisme, c'est le client qui doit sauvegarder les donn√©es de session, et donc le browser. L'authentification √† l'aide de **tokens** devient tr√®s populaires.  
Il existe diff√©rents moyen de l'impl√©menter. Dans le cadre de ce cours, nous focuserons sur la fa√ßon la plus habituelle, les **JSON Web Tokens**, ou **JWT**.

Il existe d'autres m√©canismes tr√®s modernes qui utilisent des tokens, mis en place par des tiers : **OAuth**, **OpenId**... Ces m√©canismes sont offerts par Microsoft, Google, Facebook... Nous ne les verrons pas dans le cadre de cours. N√©anmoins, √† la fin de ce cours, vous devriez √™tre apte √† pouvoir les utiliser, sous r√©serve de bien lire la documentation.

# <InternalPageTitle> Stateful VS stateless authentication  </InternalPageTitle>

Quels sont les avantages & inconv√©nients d'une authentification stateful ? et d'une authentification stateless ?

#### Authentification stateful
**Inconv√©nients** :
- La session utilise de la m√©moire pour chaque utilisateur.
- Le backend n'a aucune mani√®re de d√©terminer si le frontend s'est d√©connect√© du site ou non : gestion de l'expiration d'une session plus compliqu√©e, notamment si le frontend revient apr√®s une longue dur√©e.
- Toutes les sessions sont perdues en cas de red√©marrage du serveur (r√©authentification).
- Load balancing compliqu√© ; en effet, si un client fait une requ√™te, pendant toute la dur√©e de la session, s'il y a plusieurs serveurs qui peuvent y r√©pondre, comment est g√©r√©e la session de ce client ? Par quel(s) serveur(s) ? Comment se partagent-ils les donn√©es de session ? Ou est-ce que √ßa doit toujours √™tre le m√™me serveur qui r√©pond au m√™me client ?

**Avantages** :
- Peu gourmand en ressource point de vue processing et tr√®s rapide ; en effet, une fois qu'une session est en place, la v√©rification que le cookie contient le bon id de session se fait vite.

#### Authentification stateless
**Inconv√©nients** : 
Comme le serveur ne retient plus l'utilisateur en m√©moire, il doit utiliser de la cryptographie pour cr√©er et valider les token ; c'est donc consommateur en ressource point de vue processing.

**Avantages** : 
- Pas de session √† g√©rer, m√™me apr√®s red√©marrage du serveur, il n'y a pas de r√©authentification n√©cessaire.
- Evolutif, utilisation facile de plusieurs serveurs si du load balancing est n√©cessaire ; en effet, comme chaque requ√™te du client contient toutes les infos pour se faire autoriser, peu importe quel est le serveur qui va prendre en charge la requ√™te.

Notons que la "scalability" horizontale, la possibilit√© de permettre √† une application d'augmenter sa capacit√© de r√©pondre √† une charge grandissante simplement en ajoutant des machines, est quelque chose de tr√®s important √† notre √©poque.  
Certaines applications web ont des centaines de millions d'utilisateurs ; pour celles-ci, on ne peut pas compter sur la "scalability" verticale, c'est-√†-dire le fait d'augmenter les ressources d'une machine, en augmentant sa RAM, son processeur, son espace de stockage...

D√®s lors, dans le cadre de ce cours, nous allons pr√©f√©rer les applications web qui peuvent tourner sur des serveurs **stateless**.

# <InternalPageTitle> C'est quoi les tokens JWT ? </InternalPageTitle>

Les JSON Web token, ou JWT, appartiennent √† un standard internet permettant l'√©change s√©curis√© de tokens entre plusieurs parties.

Un JWT contient trois parties encod√©es en base64 et ressemble √† qqch du style :  
**`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.`**  
**`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.`**   
**`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`**

Voici les 3 parties d'un JWT et leurs caract√©ristiques :
- l'**ent√™te** (ou header) : un objet JSON identifiant le type de token (JWT) et l'algorithme utilis√© pour g√©n√©rer la signature du token (HS256), un algorithme de hachage. 
- le **payload** : un objet JSON permettant de sp√©cifier le **claim** ; ce sont des param√®tres optionnels pr√©cisant les affirmations associ√©es au token, comme la date d'expiration du token, son cr√©ateur, le fait que l'utilisateur est admin... g√©n√©ralement, on y met pas trop d'info, principalement l'identifiant de l'utilisateur ; si l'API a besoin de plus d'info concernant l'utilisateur, elle ira g√©n√©ralement les chercher dans son support de donn√©es.
- la **signature** : c'est une signature num√©rique construite √† partir d'un secret priv√© ou d'une cl√© publique/priv√©e, via l'algorithme pr√©cis√© dans la signature.

üí≠ C'est bien joli tout √ßa, mais comment √ßa permet de s√©curiser la session d'un utilisateur ?  
G√©n√©ralement, l'API, et elle uniquement, connait le secret priv√©. Elle va donc cr√©er le token d'un utilisateur authentifi√©, en y ajoutant le claim (ou les affirmations) qu'elle juge utile.  
Lorsque le client re√ßoit son token, il va le sauvegarder dans son browser.  
Pour chaque requ√™te o√π il devra se faire autoriser par l'API, le client enverra son token au sein d'un header de la requ√™te.  
L'API utilisera le secret priv√©, connu d'elle-m√™me uniquement, pour v√©rifier la signature du token. Si tout est OK, c'est que l'utilisateur est bien authentifi√© et que son claim est OK.

Imaginez maintenant qu'un hackeur tente de modifier le token, pour modifier le claim, notamment en changeant l'id de l'utilisateur pr√©sent dans le payload du token.
Et bien la signature ne correspondra plus √† ce token l√† ! L'API le d√©tectera.  
Pour que le hackeur r√©ussisse son acte malicieux, il est oblig√© de conna√Ætre le secret priv√© qui ne doit √™tre connu que de l'API.  
Les hackeurs devront conna√Ætre le secret priv√© afin de pouvoir g√©n√©rer un nouveau token qui sera valid√© par l'API. Pas √©vident...

Ainsi, on peut imaginer un token comme une enveloppe s√©curis√© par un cadenas tr√®s sp√©cial : ce cadenas, qui est mis sur l'enveloppe contenant, par exemple, l'identifiant d'un utilisateur, est ferm√© par la cl√© üîë que seulement conna√Æt l'API.
Si quelqu'un touche √† l'enveloppe, le cadenas ne s'ouvrira plus avec la üîë de l'API : la tentative de hackage sera d√©tect√©e ! 
Si quelqu'un tente de cr√©er une enveloppe s√©curis√©, il le fera avec une autre cl√©, **üóù** par exemple, car il ne conna√Æt pas üîë. L'API, tentant d'ouvrir l'enveloppe s√©curis√©e √† l'aide de üîë, elle ne s'ouvrira pas : la tentative de hacking sera d√©tect√©e ! 

üí≠ Est-ce que cette m√©taphore d'enveloppe s√©curis√©e vous parle ?
Attention que dans la r√©alit√©, le payload classique d'un token sera d√©codable, que l'on connaisse ou pas le secret priv√©. Il est encod√© en base64 ! Ne mettez donc jamais de secrets dans le payload d'un token !  
Si vraiment un jour vous deviez mettre un secret dans un payload, bien que d√©conseill√©, vous pourriez toujours le faire en cryptant le payload.

üëç Le m√©canisme de token assure que l'on aie une tr√®s haute probabilit√© de d√©tecter les alt√©rations faites sur les tokens, les tentatives de forgeage, gr√¢ce √† la signature de ceux-ci.  
‚ö° Par contre, si nous laissons tra√Æner des informations dans le payload d'un token, comme un password d'un utilisateur et son username, alors l√†, c'est juste un beau cadeau pour les hackeurs, il n'auront qu'√† utiliser le formulaire de connexion et prendre possession de notre identit√© üò®.

Il existe un site fort int√©ressant qui montre la structure d'un token et qui permet de les d√©coder : [jwt.io](https://jwt.io/) [[R.63]](/references/#r63). Nous l'utiliserons plus tard pour d√©coder les tokens g√©n√©r√©s par nos RESTful API.

# <InternalPageTitle> Authentification & autorisation stateless via JWT & Expres </InternalPageTitle>

## Introduction

Via un exemple concret associ√© √† notre RESTful API qui g√®re les ressources de type "pizzas", nous allons mettre en place un processus d'authentification et d'autorisation JWT.

La librairie que nous allons utiliser dans le cadre de ce cours pour g√©rer des tokens JWT est [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken).

Nous allons maintenant continuer le d√©veloppement de l'API [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model) pour ajouter des op√©rations permettant l'authentification et l'autorisation d'utilisateurs.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/auths** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/api/fat-model** (ou [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/auths**.

Veuillez installer la librairie **jsonwebtoken** au sein de votre nouveau projet **auths** :
```bash
npm i jsonwebtoken
```

## M√©canisme d'authentification et cr√©ation du token

Toujours √† l'aide d'Express, nous allons cr√©er un router **auths** qui mettra √† disposition les op√©rations de **login** et de **register**. 
Voici le contrat associ√© √† ces nouvelles op√©rations :

##### Op√©rations sur les ressources de type "auths"
| URI | M√©thode HTTP | Op√©ration |
|---|---|---|---|
| **auths/login** | POST | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |
| **auths/register** | POST | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |

<br/>

Le mod√®le **users** s'occupera de cr√©er les utilisateur, de v√©rifier leurs credentials ainsi que de cr√©er des token.

Voici le workflow attendu pour une op√©ration de **login** ou de **register** :

<ScrollableImage name="login.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une RESTful API pour s'authentifier et obtenir un JWT</figcaption>

Ce que l'on voit dans l'image ci-dessus : 
- si le mod√®le consid√®re que l'utilisateur est authentifiable, que ses credentials sont OK, alors il va utiliser une librairie **jwt** et la m√©thode **sign** pour cr√©er un token. 
- le token est envoy√© dans le body de la r√©ponse √† l'utilisateur. 

Ce que l'on ne voit pas dans l'image ci-dessus :
- c'est le job du client de sauvegarder le token. Si l'application cliente est un browser, alors celui-ci pourra √™tre sauvegard√© dans le web storage du browser.
- l'application cliente peut √™tre faite avec n'importe quelle technologie. Par exemple, nous pourrons utiliser REST Client pour faire une requ√™te √† l'API...

Dans notre RESTful API, nous avons d√©cid√© que lorsqu'un client s'enregistre, quand il fait appel √† l'op√©ration **register** pour cr√©er un compte, l'API consid√®re automatiquement que cet utilisateur est authentifi√©. Tout comme la m√©thode **login**, la m√©thode **register** cr√©era et renverra un token JWT √† l'utilisateur.

NB : Il est possible d'envisager un workflow diff√©rent : apr√®s le **register**, l'application demanderait √† l'utilisateur un **login**, **register** ne renvoyant jamais de token √† l'utilisateur.

Nous allons √† pr√©sent mettre en place le code permettant d'impl√©menter le workflow que l'on vient de d√©couvrir.

Veuillez cr√©er le mod√®le **users** en cr√©ant le fichier **/models/users.js** et y inclure ce code :
```js numbered highlighting="1,5-6,23-27,29-31,34,43-47,49-52,54"
const jwt = require('jsonwebtoken');
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jwtSecret = 'ilovemypizza!';
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const jsonDbPath = path.join(__dirname, '/../data/users.json');

const defaultUsers = [
  {
    id: 1,
    username: 'admin',
    password: 'admin',
  },
];

function login(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;
  if (userFound.password !== password) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function register(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username) {
  const users = parse(jsonDbPath, defaultUsers);
  const indexOfUserFound = users.findIndex((user) => user.username === username);
  if (indexOfUserFound < 0) return undefined;

  return users[indexOfUserFound];
}

function createOneUser(username, password) {
  const users = parse(jsonDbPath, defaultUsers);

  const createdUser = {
    id: getNextId(),
    username,
    password,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

function getNextId() {
  const users = parse(jsonDbPath, defaultUsers);
  const lastItemIndex = users?.length !== 0 ? users.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = users[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

module.exports = {
  login,
  register,
  readOneUserFromUsername,
};

```

Dans le code ci-dessus, **jwtSecret** est le secret priv√© connu uniquement du serveur. C'est la m√™me secret qu'il faudra utiliser pour v√©rifier un token.  

**`jwt.sign()`** permet de cr√©er le token et ses 3 parties :
- le payload du token, la 2√®me partie du token, est compl√©t√© principalement via le permier argument de **sign()** ; ici, le token affirme que l'utilisateur poss√©dant le **username** donn√© est authentifi√©.
- le payload du token sera aussi modifi√© sur base de la dur√©e d'expiration du token, selon l'argument **expiresIn**.
- **jwtSecret** est utilis√© pour cr√©er la 3√®me partie du token, sa signature.

Il faut maintenant que nous cr√©ions le router **auths** offrant les op√©rations de **login** et de **register**, en faisant appel au mod√®le **users**.  
Veuillez cr√©er le fichier **/routes/auths.js** et y inclure le code suivant :
```js
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  return res.json(authenticatedUser);
});

/* Login a user */
router.post('/login', (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  return res.json(authenticatedUser);
});

module.exports = router;
```

Il n'y a rien de bien sp√©cial √† ce code. On fait simplement appel aux op√©rations du mod√®le **users**.

Attention, il faut rajouter le nouveau router au sein de **app.js** pour que notre API puisse offrir les nouvelles op√©rations. Veuillez ajouter ce code dans **/app.js** :
```js highlighting="7,18"
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');
const authsRouter = require('./routes/auths');

const app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', pizzaRouter);
app.use('/auths', authsRouter);

module.exports = app;
```

Veuillez d√©marrer votre API **auths**.

üí≠ Comment tester ces nouvelles op√©rations ?
H√© bien rien de neuf, on va utiliser REST Client.

Veuillez cr√©er le fichier **/REST Client/auths.http** et y ajouter le code suivant :
```http
@baseUrl = http://localhost:3000

### Try to login an unknow user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"unknown",
    "password":"admin"
}

### Login the default admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}


### Create the manager user
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

### Login the manager user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}
```

Veuillez ex√©cuter les diff√©rentes requ√™tes. Tout devrait fonctionner, vous devriez r√©cup√©rer le username et le token d'un utilisateur authentifi√©.

Pour le fun, nous allons d√©coder un token. Veuillez copier le token de ce que renvoie votre API pour la requ√™te de login de l'utilisateur **manager** (qqch qui doit ressembler √† une string du genre : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjEyNDg1MjksImV4cCI6MTc0NzY0ODUyOX0.JvYzM0gtmVkqFr9R3f1Bf6ow_QuyHJY-vedJ39N7JKw`).

Veuillez vous rendre sur le site [JWT](https://jwt.io/) et coller votre token dans le champs **Encoded**. Dans la colonne **Decoded**, vous devriez voir l'algorithme utilis√© par la m√©thode **sign**, ainsi que les donn√©es pr√©sentes dans le payload, dont `"username": "manager"` !  
Vous comprenez pourquoi on n'ajoute pas des secrets dans un token üòâ.

# <InternalPageTitle> üç¨ Cacher ses secrets </InternalPageTitle>

Dans ce cours-ci, nous ne verrons pas directement comment faire en sorte que le secret,  permettant de signer & v√©rifier les token, ne soit pas pr√©sent sur le web repository de vos API (par exemple ici le mod√®le **users.js** hardcode ce secret). En effet, pour des raisons de s√©curit√©, si votre secret est visible pour tous les d√©veloppeurs qui acc√®de √† votre repository public, c'est un probl√®me.  
Si vous souhaitez d√©couvrir comment faire en sorte de rendre invisible des informations sensibles sur un web repository, tout en pouvant b√©n√©ficiant de ces infos dans votre environnement de d√©veloppement, vous pouvez utiliser la librairie [dotenv](https://www.npmjs.com/package/dotenv) qui permet de g√©rer facilement des variables d'environnement. C'est ce genre de librairies qui est utilis√©e par les professionnels pour cacher leurs secrets et certaines variables de configuration, comme le password pour se connecter √† une DB, l'URL vers une API, le port de l'application...

# <InternalPageTitle> M√©canisme d'autorisation et v√©rification du token</InternalPageTitle>

Suite au **register** ou au **login** de l'utilisateur, tel qu'il a √©t√© d√©cid√© pour notre RESTful API, celui-ci a re√ßu un token. C'est le job de l'application cliente de trouver un moyen de sauvegarder ce token. 

Lorsqu'une application client souhaite cr√©er une pizza, on souhaite autoriser cette op√©ration qu'√† l'administrateur du site g√©rant la pizz√©ria.  
Nous d√©cidons donc pour l'op√©ration de cr√©ation de pizza que l'utilisateur doit non seulement √™tre authentifi√©, mais qu'en plus, il doit √™tre l'admin.

Pour que l'application client qui fait la requ√™te √† l'API puisse s'autoriser, elle doit ajouter un **authorization header** √† sa requ√™te contenant comme valeur le token re√ßu lors du **login** ou du **register** :

<ScrollableImage name="authorizeOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation valide</figcaption>

Le router de "pizzas", avant m√™me de passer la requ√™te √† la route **POST /pizzas**, va lancer la fonction middleware d'autorisation nomm√©e **authorize**. La fonction middleware **authorize** va s'occuper de v√©rifier le token envoy√© par le client dans un header √† l'aide de la m√©thode **verifiy** de la librairie **jwt**.

üí≠ Si le token est valide, est-ce que √ßa signifie que l'utilisateur est bien authentifi√© ?
H√© bien non, car imaginez qu'entre le moment o√π l'utilisateur se soit logu√©, il ait √©t√© supprim√© de l'application par un admin... dans ce cas-ci, on ne veut pas l'autoriser √† ajouter une pizza au menu de la pizzeria ! Il n'est p-e m√™me plus un employ√©, il souhaite p-e √©crire du contenu malicieux üò®

Donc si le token est valide, **authorize** fera appel au mod√®le de **users** pour v√©rifier que l'utilisateur existe bien dans le support de donn√©es (fichiers JSON, base de donn√©es ou autres) et pour obtenir toutes les infos sur cet utilisateur. Si l'utilisateur existe, alors cela signifie que l'utilisateur est bien authentifi√©. La fonction middleware **authorize** va passer la main √† une autre fonction middleware pour v√©rifier que l'utilisateur est bien l'admin.

üí≠ Comment est-ce que **authorize** peut faire appel au mod√®le pour v√©rifier que l'utilisateur existe bien ? Est-ce que cela signifie que le token doit contenir tout un tas de donn√©es sur l'utilisateur ? 
üëç En r√®gle g√©n√©rale, on va juste mettre un identifiant de l'utilisateur dans ce qu'on appelle le **payload** du token. C'est ensuite l'API, suite au d√©codage de l'identifiant de l'utilisateur, qui fera appel au support de donn√©es pour retrouver toutes les donn√©es de l'utilisateur.

NB : notez que l'on pourrait aussi laisser la fonction **createOnePizza** s'occuper de v√©rifier que l'utilisateur demandant la cr√©ation de la pizza soit bien l'admin. Ici, comme il s'agit de v√©rifier que le contrat de l'API soit respect√©, c'est-√†-dire que l'utilisateur soit bien authentifi√© & admin, alors on pr√©f√®re r√©aliser cette action en dehors du mod√®le, car dans nos choix architecturaux au niveau de nos RESTful API, nous avons d√©cid√© que ce n'est pas le mod√®le qui s'occupe de pr√©senter les donn√©es aux clients.

La fonction middleware **isAdmin** va v√©rifier que l'utilisateur est bien l'admin. Si c'est OK, elle passera la main √† la fonction middleware qui g√®re la route **POST /pizzas** au sein du router de pizzas en faisant l'appel √† la fonction **next**.

Maintenant que le client a les bons privil√®ges, l'op√©ration de cr√©ation de la pizza peut donc √™tre autoris√©e. L'op√©ration de **createOnePizza** du mod√®le renverra la nouvelle pizza au router qui s'occupera de pr√©senter la nouvelle pizza au client, au format JSON.

Par contre, voici le workflow si le token n'est pas valide :

<ScrollableImage name="authorizeNOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation invalide</figcaption>

Dans ce cas l√†, **authorize** ne passe pas la main √† **isAdmin** ni m√™me √† la fonction middleware qui g√®re la route **POST /pizzas**.  
La fonction middleware **authorize** renvoie directement un code d'erreur **401 Unauthorized** au client. 

Vous pourriez aussi imaginer le workflow o√π le client envoie un token valide, mais l'utilisateur associ√© n'est pas admin. Dans ce cas-ci, **authorize** ferait appel √† **isAdmin**, mais **isAdmin** renverrait directement un code d'erreur **403 Forbidden** au client.  
En effet, l'API indiquerait ainsi qu'elle aurait v√©rifi√© que l'utilisateur est bien authentifi√©, mais que celui ne poss√®de pas les privil√®ges suffisant pour acc√©der √† l'op√©ration demand√©e.

üò® Wow, le workflow d'autorisation pour la cr√©ation d'une pizza est assez long.  Nous allons maintenant l'impl√©menter. Nous vous inqui√©tez pas, ce qui importe dans le code qui va suivre, ce n'est pas de savoir √©crire tout le code, mais de bien comprendre le m√©canisme. En effet, en r√®gle g√©n√©rale, vous allez utiliser des librairies vous permettant d'autoriser les acc√®s aux op√©rations de vos API. Vous √©crirez donc rarement le m√©canisme d'autorisation, par contre, vous devrez pouvoir utiliser ces m√©canismes.

Veuillez cr√©er les nouvelles fonctions middleware **authorize** et **isAdmin** au sein d'un nouveau fichier **/utils/auths.js** :
```js numbered highlighting="1,4,7,11"
const jwt = require('jsonwebtoken');
const { readOneUserFromUsername } = require('../models/users');

const jwtSecret = 'ilovemypizza!';

const authorize = (req, res, next) => {
  const token = req.get('authorization');
  if (!token) return res.sendStatus(401);

  try {
    const decoded = jwt.verify(token, jwtSecret);
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) return res.sendStatus(401);

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error('authorize: ', err);
    return res.sendStatus(401);
  }
};

const isAdmin = (req, res, next) => {
  const { username } = req.user;

  if (username !== 'admin') return res.sendStatus(403);
  return next();
};

module.exports = { authorize, isAdmin };
```

Quelques explications sur le code de la fonction middleware **authorize** : 
- Gr√¢ce √† `req.get('authorization')`, on r√©cup√®re le token qui a √©t√© envoy√© par le client au sein de l'**authorization header** de la requ√™te, c'est une string.
- La m√©thode `jwt.verify(token, jwtSecret)` v√©rifie tant la signature du token que le fait que le token n'a pas encore expir√©. Elle utilise le secret **jwtSecret** qui doit √™tre le m√™me que celui pris en compte lors de la cr√©ation du token.
- Elle charge toutes les donn√©es de l'utilisateur authentifi√© au sein de l'objet **request**, dans **user**. Cela est une bonne pratique, cela permet, pour toute la dur√©e du traitement de cette requ√™te, de mettre √† disposition ces donn√©es √† toutes les fonctions middleware.  
üí≠ Mais pourquoi faire cela ?
Imaginez que vous faites un appel √† une base de donn√©es externes √† chaque fois que vous souhaitez obtenir les informations d'un utilisateur... Cela est tr√®s consommateur en temps... Lorsque vous allez utiliser d'autres fonctions middleware comme **isAdmin**, vous n'avez plus besoin de faire appel √† la base de donn√©es.
- üí≠ Qu'est-ce que ce code : `const { username } = decoded;` ?  
C'est ce que l'on appelle du **destructuring assignement**, c'est une fa√ßon tr√®s concise en JS de cr√©er des variables √† partir de propri√©t√©s d'objets ou des valeurs d'arrays.  
Imaginez ici que la valeur de `decoded` soit `{ username: 'admin', iat: 1661251095, exp: 1747651095 }`. Ce code `const { username } = decoded;` est l'√©quivalent de `const username = decoded.username;`. OK, mais √ßa n'a pas vraiment de valeur ajout√©e ici, c'est juste un poil plus concis... Cela devient vraiment int√©ressant quand vous souhaitez cr√©er plusieurs variables, comme pour l'exemple donn√©, on pourrait cr√©er 3 variables ainsi `const { username, iat, exp } = decoded;` au lieu d'√©crire :
```js
const username = decoded.username;
const iat = decoded.iat;
const exp = decoded.exp;
```
- Pour en savoir plus sur la puissance du **destructuring assignement**, vous pouvez consulter la [documentation de MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) [[R.64]](/references/#r64).
- Si tout est OK, **isAdmin** fait appel √† **next()**, qui sera la prochaine fonction middleware qui est pr√©sente apr√®s l'appel de **authorize**.


La fonction middleware **isAdmin** r√©cup√®re les donn√©es de l'utilisateur authentifi√© via l'objet `req.user` et le **destructuring assignement**.  
Si l'utilisateur n'est pas **admin**, c'est le code '**403 Forbidden**' qui est renvoy√© √† l'application cliente, signifiant que l'utilisateur est bien authentifi√©, mais il n'a pas les privil√®ges pour acc√©der √† l'op√©ration demand√©e (cr√©ation de pizza).  
Si tout est OK, **isAdmin** fait appel √† **next()**, qui sera la prochaine fonction middleware qui est pr√©sente apr√®s l'appel de **isAdmin**.

O√π allons-nous utiliser ces nouvelles fonctions middleware ?

Nous pouvons le faire au niveau que nous souhaitons, soit au niveau :
- de l'application, pour toutes les routes, via `app.use(authorize)`.
- d'un router, pour toutes les routes associ√©es ; par exemple, on pourrait dire que toutes les routes du router de pizzas sont prot√©g√©es par une autorisation JWT. On √©crirait : `app.use("/pizzas", authorize, pizzaRouter);`. Cela signifierait que toutes les op√©rations sur des ressources de type "pizzas" ne seraient autoris√©es que si l'utilisateur est authentifi√©. Cela serait probl√©matique pour deux raisons :
    - On veut pouvoir afficher le menu des pizzas pour tous les utilisateurs, m√™me s'ils sont anonymes.
    - On ne veut pas simplement v√©rifier qu'un utilisateur est authentifi√© pour cr√©er une pizza, on veut aussi v√©rifier qu'il est admin.
- d'une route, pour une op√©ration de notre RESTful API. C'est ce que nous souhaitons faire ici. Veuillez mettre √† jour le code du router de "pizzas" au sein de **/routes/pizzas.js** :
```js highlighting="2,7"
// See existing code
const { authorize, isAdmin } = require('../utils/auths');

// See existing code

// Create a pizza to be added to the menu.
router.post('/', authorize, isAdmin, (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const createdPizza = createOnePizza(title, content);

  return res.json(createdPizza);
});
```

Ainsi, nous avons juste fait l'appel de deux fonctions middleware pour v√©rifier :
- **que l'utilisateur est authentifi√©** via **authorize** ; si tout est OK au niveau du token fournit par l'application cliente, **authorize** fait appel via **next()** √† la prochaine fonction middleware. Dans ce cas-ci, c'est **isAdmin**. S'il y a un probl√®me, **authorize** termine le traitement de la requ√™te en envoyant un code d'erreur au client et les prochaines fonctions middleware (**isAdmin**, puis la fonction arrow) ne sont pas ex√©cut√©es.
- **que l'utilisateur est admin** via **isAdmin** ; si tout est OK, que l'utilisateur authentifi√© est l'admin, **isAdmin** fait appel via **next()** √† la prochaine fonction middleware. Dans ce cas-ci, c'est la fonction arrow qui appelle `createOnePizza` pour cr√©er la pizza, la fonction traitant l'op√©ration demand√©e. Si l'utilisateur authentifi√© n'est pas l'admin, alors **isAdmin** termine le traitement en envoyant un code d'erreur au client et la fonction traitant de l'op√©ration de cr√©ation n'est pas ex√©cut√©e.

Comment pouvons-nous tester l'op√©ration de cr√©ation d'une pizza ? Via REST Client.
Tentons le coup √† l'aide de cette requ√™te (elle est d√©j√† pr√©sente dans **/REST Client/pizzas.http**) :
```http
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Apr√®s avoir ex√©cut√© cette requ√™te, vous devriez avoir re√ßu un status code '**401 Unauthorized**'.
Et bien oui, nous n'avons pas envoy√© de token, nous ne pouvons donc pas √™tre autoris√©.  
Au prochain point nous allons voir comment utiliser REST Client pour sauvegarder de l'information, comme un token, suite √† une requ√™te vers une API.

# <InternalPageTitle> Client REST avec JWT </InternalPageTitle>

Pr√©c√©demment, nous avons appris √† utiliser REST Client, l'extension de VS Code, pour faire des requ√™tes vers des API.

Voici quelques notions suppl√©mentaire pour utiliser REST Client avec des **JWT** :
- Il est possible de cr√©er des **Request Variables** afin de r√©cup√©rer la r√©ponse associ√©e 
√† une requ√™te au sein d'une variable.
- On va donc pouvoir r√©cup√©rer le token, suite √† une requ√™te d'authentification, 
au sein d'une **Request Variable**, pour ensuite fournir ce token dans le 
¬´ **Authorization header** ¬ª de toutes les requ√™tes demandant une autorisation JWT.

Si vous souhaitez plus d'infos sur les **Request Variables**, vous pouvez consulter la [documentation de REST Client](https://github.com/Huachao/vscode-restclient#request-variables) [[R.55]](/references/#r55).

Voici comment mettre √† jour le script **/REST Client/pizzas.http** pour cr√©er une pizza en passant le token de l'utilisateur **admin** :

```http
### Create a pizza by using the admin account
#### First login as the admin
##### Define a request variable nammed admin :
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Pour tester l'op√©ration de cr√©ation de pizza, veuillez d'abord ex√©cuter la premi√®re requ√™te, puis la seconde donn√©e ci-dessus.

A ce stade-ci, il serait aussi int√©ressant de tester certains cas d'erreurs associ√©s aux tokens. Veuillez compl√©ter le script **/REST Client/pizzas.http** avec :
```http
### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
##### 2.1.1 Define a request variable nammed manager
# @name manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

##### 2.1.2 Define a file variable to simplify the access to the token of manager
@managerToken = {{manager.response.body.token}}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{managerToken}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Nous voyons qu'√† l'aide de REST Client, nous pouvons utiliser une **File Variable** pour allouer une partie de la r√©ponse faite √† une requ√™te.  
Dans ce cas, on peut faire appel √† l'API en passant le token via la **File Variable** nomm√© **managerToken** (`Authorization: {{managerToken}}`) au lieu d'utiliser une partie seulement de la **Request Variable** nomm√©e **manager** (`Authorization: {{manager.response.body.token}}`).  
Cela permet de cr√©er des requ√™tes plus concises.

# <InternalPageTitle> Protection des op√©rations d'√©criture d'une API </InternalPageTitle>

Veuillez mettre √† jour votre RESTful API g√©rant les pizzas afin que toutes les op√©rations d'√©criture soient prot√©g√©es par une autorisation JWT, n'autorisant que l'utilisateur **admin**.

Voici le code √† mettre √† jour dans **/routes/pizzas** pour correctement autoriser les op√©rations de suppression et de modification sur des ressources de type "pizzas":
```js highlighting="2,11"
// Delete a pizza from the menu based on its id
router.delete('/:id', authorize, isAdmin, (req, res) => {
  const deletedPizza = deleteOnePizza(req.params.id);

  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', authorize, isAdmin, (req, res) => {
  const title = req?.body?.title;
  const content = req?.body?.content;

  if ((!title && !content) || title?.length === 0 || content?.length === 0) {
    return res.sendStatus(400);
  }

  const updatedPizza = updateOnePizza(req.params.id, { title, content });

  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});
```

Pour vous assurer que les op√©rations de suppression et de modification sont bien fonctionnelles, veuillez mettre √† jour les requ√™tes associ√©es afin d'utiliser un token. Veuillez mettre √† jour **/REST Client/pizzas.http** en ajoutant ces deux lignes :
```http numbered highlighting="25,30"
### Create a pizza by using the admin account
#### First login as the admin
##### Define a request variable nammed admin
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2
Authorization: {{admin.response.body.token}}

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cutez les requ√™tes de type DELETE et de type PATCH afin de vous assurer que l'API est en ordre.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**auths**".

En cas de souci, vous pouvez utiliser le code du tutoriel [auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).