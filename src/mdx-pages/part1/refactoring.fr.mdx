---
title: "Refactoring de l'API"
description: "Refactoring √† l'aide d'un fat model"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1)</PathViewerItem>
    <PathViewerItem selected> e) Refactoring </PathViewerItem>
</PathViewer>

# e) Refactoring √† l'aide d'un "fat model"

<InternalPageMenu>
  <InternalPageMenuItem> Architectures possibles ? </InternalPageMenuItem>
  <InternalPageMenuItem> Architecture Express & "fat model" </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.4 : Refactoring de la RESTfull API pour myMovies </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Architectures possibles ? </InternalPageTitle>

Si nous reprenons le code actuel du tutoriel de l'API g√©rant des pizzas ([api-persistence](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/persistence)), nous pouvons d√©tecter que celui-ci pourrait √™tre plus propre.

Par exemple, le routeur de "pizzas" s'occupe tant de g√©rer les requ√™tes des clients que d'acc√©der directement aux donn√©es.  
G√©n√©ralement, nous pr√©f√©rons s√©parer le code g√©rant les acc√®s aux donn√©es du code g√©rant la pr√©sentation du r√©sultat des op√©rations.

On peut donc se demander comment s√©parer le code traitant de sujets diff√©rents, o√π ayant des responsabilit√©s fort diff√©rentes. Il existe une multitude d'architectures possibles, voici par exemple certains des plus grands noms :
- **Architecture MVC (Model View Controller)** ; au niveau backend, ce genre d'architecture est g√©n√©ralement tr√®s utile quand on fait des MPA (ou Multi-Page Applications) via du Server-Side Rendering. Les **Views** permettent de g√©n√©rer le frontend √† l'aide d'un moteur de templating ; le **Controller** s'occupe de traiter les requ√™tes en appelant le **Model** pour l'acc√®s aux op√©rations sur les donn√©es et en renvoyant les **Views** ad√©quates. Pour une API, cette architecture n'est pas la plus adapt√©e.
- **Architecture classique "three-tiers"** ; au nivau backend, quand on d√©veloppe une architecture trois tiers, cela signifie que l'on d√©coupe notre API en trois couches :
  - **couche de pr√©sentation** : cette couche est responsable de pr√©senter les ressources aux clients et d'interpr√©ter les repr√©sentations des ressources donn√©es dans les requ√™tes ;
  - **couche business** : cette couche s'occupe de toute la logique de l'API, elle fait l'interm√©diaire entre la couche de pr√©sentation et la couche de donn√©es ;
  - **couche de donn√©es** : cette couche s'occupe des acc√®s aux donn√©es et permet notamment la persistance des ressources au sein de bases de donn√©es.  
  Le mod√®le trois tiers est fort int√©ressant, mais il demande un peu trop d'√©criture de codes sans grande valeur ajout√©e quand nous utilisons le framework Express.
- ...

Finalement, parmi les architectures classiques, il n'y a pas r√©ellement une architecture qui colle parfaitement √† ce qui est offert par le framework Express, sans devoir √©crire du code sans valeur ajout√©e.  

Ainsi, nous allons simplement cr√©er notre propre architecture "maison", sur base de ces points :
- On souhaite pouvoir facilement remplacer la couche d'acc√®s aux donn√©es sans changer la repr√©sentation des ressources ; en effet, dans un premier temps, nous sauvegarderons des donn√©es dans des fichiers JSON. Plus tard, si l'on venait √† sauvegarder les donn√©es dans un syst√®me de gestion de base de donn√©es, on ne veut pas devoir mettre √† jour le code prenant en compte les requ√™tes des clients et pr√©sentant la r√©ponse √† ces requ√™tes ; en gros, on souhaite que le code de nos routers, au sein d'Express, soit ind√©pendant de l'impl√©mentation des acc√®s aux donn√©es.
- Nous n'avons pas vraiment de contraintes pour l'aspect "business" de nos APIs : la logique de l'application peut soit s'associer √† la couche de donn√©es, soit √† la couche pr√©sentation. N√©anmoins, nous allons pr√©f√©rer associer un maximum de la logique de notre application √† ce que nous allons appeler un **fat model**. Le **fat model** contiendra toutes les op√©rations possibles sur les ressources, ainsi que les acc√®s aux donn√©es.
- Le **fat model** peut √™tre soit √©crit en orient√© objet, soit simplement √™tre un module fournissant des fonctions. Dans le cadre de ce cours, nous choisissons de pr√©senter un maximum de programmation fonctionnelle plut√¥t que de l'orient√© objet.  
  N√©anmoins, n'h√©sitez pas √† √©crire des classes si cela vous tient √† coeur üòâ.

# <InternalPageTitle> Architecture Express & "fat model" </InternalPageTitle>

Voici l'architecture que nous allons appliquer dans nos prochaines API :

<ScrollableImage name="architecture.png" minWidth="859px" maxWidth="859px" />
<figcaption>Architecture recommand√©e pour ce cours</figcaption>

Voici quelques explications sur ce diagramme que nous allons appliquer dans le prochain tutoriel :

1. Un client fait la requ√™te √† l'API demandant de lire toutes les pizzas.
2. Le router de "pizzas" prend le r√¥le de "Controller". Il s'occupe de traiter de la requ√™te et d'appeler une op√©ration du **fat model** pour acc√©der aux ressources.
3. Le **fat model** s'occupe d'acc√©der aux donn√©es, qui se trouvent au sein d'un fichier JSON, et de les lire.
4. Le **fat model** retourne des donn√©es sous forme d'un objet JS au router de "pizzas".
5. Le router de "pizzas" renvoient une repr√©sentation JSON de l'objet JS, un array de pizzas, au client.

Nous allons maintenant faire un refactor de notre API de gestion des pizzas en cr√©ant et utilisant un "fat model".

Au sein de votre repo **web2**, √† l'aide du boilerplate du cours [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate), veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/fat-model**.

Si vous ne voyez pas comment utiliser le boilerplate, tout est expliqu√© dans le **README** associ√© au repository du boilerplate.  
N'h√©sitez pas √† le lire ; )

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/fat-model**.

Nous allons commencer par cr√©er le **fat model** offrant les op√©rations sur les pizzas.   
Veuillez cr√©er le fichier **/models/pizzas.js**.  
Au sein de ce fichier, veuillez ajouter le code s'occupant des op√©rations sur les ressources de type "pizzas" :

```js
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jsonDbPath = path.join(__dirname, '/../data/pizzas.json');

const defaultPizzas = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

function readAllPizzas(orderBy) {
  const orderByTitle = orderBy?.includes('title') ? orderBy : undefined;
  let orderedMenu;
  const pizzas = parse(jsonDbPath, defaultPizzas);
  if (orderByTitle)
    orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  const allPizzasPotentiallyOrderd = orderedMenu ?? pizzas;
  return allPizzasPotentiallyOrderd;
}

function readOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const indexOfPizzaFound = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (indexOfPizzaFound < 0) return undefined;

  return pizzas[indexOfPizzaFound];
}

function createOnePizza(title, content) {
  const pizzas = parse(jsonDbPath, defaultPizzas);

  const createdPizza = {
    id: getNextId(),
    title,
    content,
  };

  pizzas.push(createdPizza);

  serialize(jsonDbPath, pizzas);

  return createdPizza;
}

function getNextId() {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const lastItemIndex = pizzas?.length !== 0 ? pizzas.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = pizzas[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

function deleteOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;
  const deletedPizzas = pizzas.splice(foundIndex, 1);
  const deletedPizza = deletedPizzas[0];
  serialize(jsonDbPath, pizzas);

  return deletedPizza;
}

function updateOnePizza(id, propertiesToUpdate) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;

  const updatedPizza = { ...pizzas[foundIndex], ...propertiesToUpdate };

  pizzas[foundIndex] = updatedPizza;

  serialize(jsonDbPath, pizzas);

  return updatedPizza;
}

module.exports = {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
};
```

Maintenant, il ne reste plus qu'√† mettre √† jour le router **/routes/pizzas.js** afin de faire les appels aux fonctions offertes par le mod√®le :

```js
const express = require('express');
const {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
} = require('../models/pizzas');

const router = express.Router();

/* Read all the pizzas from the menu
   GET /pizzas?order=title : ascending order by title
   GET /pizzas?order=-title : descending order by title
*/
router.get('/', (req, res) => {
  const allPizzasPotentiallyOrdered = readAllPizzas(req?.query?.order);

  return res.json(allPizzasPotentiallyOrdered);
});

// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  const foundPizza = readOnePizza(req.params.id);

  if (!foundPizza) return res.sendStatus(404);

  return res.json(foundPizza);
});

// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content =
    req?.body?.content?.length !== 0 ? req.body.content : undefined;

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const createdPizza = createOnePizza(title, content);

  return res.json(createdPizza);
});

// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  const deletedPizza = deleteOnePizza(req.params.id);

  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  const title = req?.body?.title;
  const content = req?.body?.content;

  if ((!title && !content) || title?.length === 0 || content?.length === 0) {
    return res.sendStatus(400);
  }

  const updatedPizza = updateOnePizza(req.params.id, { title, content });

  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});

module.exports = router;
```

Lancer votre API soit via le debugger, soit via la commande **`npm run dev`**.  
Veuillez ensuite tester que tout fonctionne bien en ex√©cutant les requ√™tes HTTP d√©j√† pr√©sentes dans le r√©pertoire **REST Client** du boilerplate.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**fat-model**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

# <InternalPageTitle> Exercice 1.4 : Refactoring de la RESTfull API pour myMovies </InternalPageTitle>

Vous allez faire un nouveau refactor de la RESTful API de **myMovies**, afin de restructurer l'architecture de l'application selon l'architecture recommand√©e, en utilisant un "fat model" pour g√©rer les op√©rations sur les films.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :

- Veuillez cr√©er un nouveau projet dans votre repository local et votre web repository (normalement appel√© **web2**) nomm√© **/exercises/module5/5.2** sur base d'une copie de votre Exercice 5.1 ou sur base du boilerplate : [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate).
- Faites un refactor de votre API g√©rant les films afin que tout ce qui traite des op√©rations sur les ressources soit fait au sein du mod√®le **/models/films.json** ou **/models/movies.json**.
- Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide du REST Client en copiant les requ√™tes d√©velopp√©es pour l'Exercice 4.1 (fichier **films.http** du r√©pertoire **REST Client**). Normalement, il n'y a pas de nouvelles requ√™tes √† √©crire, il suffit juste de les ex√©cuter.

Le code de votre application web doit donc se trouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module5/5.2**.

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 5 : API with fat-model**".
