---
title: "Refactoring de l'API"
description: "Refactoring √† l'aide d'un fat model"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1)</PathViewerItem>
    <PathViewerItem selected> d) Refactoring </PathViewerItem>
</PathViewer>

# d) Refactoring √† l'aide d'un "fat model"

<InternalPageMenu>
  <InternalPageMenuItem> Architectures web possibles pour une API ? </InternalPageMenuItem>
  <InternalPageMenuItem> Architecture Express & "fat model" </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.9 : Refactoring √† l'aide d'un fat model </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.10 : Encore un fat model </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Architectures web possibles pour une API ? </InternalPageTitle>

Si nous reprenons le code actuel du tutoriel de l'API g√©rant des pizzas ([api-persistence](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/persistence)), nous pouvons d√©tecter que celui-ci pourrait √™tre plus propre.

Par exemple, le routeur de "pizzas" s'occupe tant de g√©rer les requ√™tes des clients que d'acc√©der directement aux donn√©es.  
G√©n√©ralement, nous pr√©f√©rons s√©parer le code g√©rant les acc√®s aux donn√©es du code g√©rant la pr√©sentation du r√©sultat des op√©rations.

On peut donc se demander comment s√©parer le code traitant de sujets tr√®s diff√©rents. Il existe une multitude d'architectures possibles, voici par exemple certains des plus grands noms :
- **Architecture MVC (Model View Controller)** ; au niveau backend, ce genre d'architecture est g√©n√©ralement tr√®s utile quand on fait des MPA (ou Multi-Page Applications) via du Server-Side Rendering. Les **Views** permettent de g√©n√©rer le frontend √† l'aide d'un moteur de templating ; le **Controller** s'occupe de traiter les requ√™tes en appelant le **Model** pour l'acc√®s aux op√©rations sur les donn√©es et en renvoyant les **Views** ad√©quates. Pour une API, cette architecture n'est pas la plus adapt√©e.
- **Architecture classique "three-tier"** ; au nivau backend, quand on d√©veloppe une architecture trois tiers, cela signifie que l'on d√©coupe notre API en trois couches :
  - **couche de pr√©sentation** : cette couche est responsable de pr√©senter les ressources aux clients et d'interpr√©ter les repr√©sentations des ressources donn√©es dans les requ√™tes ;
  - **couche business** : cette couche s'occupe de toute la logique de l'API, elle fait l'interm√©diaire entre la couche de pr√©sentation et la couche de donn√©es ;
  - **couche de donn√©es** : cette couche s'occupe des acc√®s aux donn√©es et permet notamment la persistance des ressources au sein de bases de donn√©es.  
  Le mod√®le trois tiers est fort int√©ressant, mais il demande un peu trop d'√©criture de codes sans grande valeur ajout√©e quand nous utilisons le framework Express.
- ...

Finalement, parmi les architectures classiques, il n'y a pas r√©ellement une architecture qui colle parfaitement √† ce qui est offert par le framework Express, sans devoir √©crire du code sans valeur ajout√©e.  

Ainsi, nous allons simplement cr√©er notre propre architecture "maison", sur base de ces points :
- On souhaite pouvoir **facilement remplacer la couche d'acc√®s aux donn√©es sans changer la repr√©sentation des ressources** ; en effet, dans un premier temps, nous sauvegarderons des donn√©es dans des fichiers JSON. Plus tard, si l'on venait √† sauvegarder les donn√©es dans un syst√®me de gestion de base de donn√©es, on ne veut pas devoir mettre √† jour le code prenant en compte les requ√™tes des clients et pr√©sentant la r√©ponse √† ces requ√™tes ; en gros, on souhaite que le code de nos routers, au sein d'Express, soit ind√©pendant de l'impl√©mentation des acc√®s aux donn√©es.
- Nous n'avons pas vraiment de contraintes pour l'aspect "business" de nos APIs : la logique de l'application peut soit s'associer √† la couche de donn√©es, soit √† la couche pr√©sentation. N√©anmoins, nous allons pr√©f√©rer **associer un maximum de la logique de notre application** √† ce que nous allons appeler un **fat model**. Le **fat model** contiendra toutes les **op√©rations possibles sur les ressources**, ainsi que les **acc√®s aux donn√©es**.
- Le **fat model** peut √™tre soit √©crit en orient√© objet, soit simplement √™tre un module fournissant des fonctions. Dans le cadre de ce cours, nous choisissons de pr√©senter un maximum de programmation fonctionnelle plut√¥t que de l'orient√© objet.  
N√©anmoins, n'h√©sitez pas √† √©crire des classes si cela vous tient √† coeur üòâ.

# <InternalPageTitle> Architecture Express & "fat model" </InternalPageTitle>

Voici l'architecture que nous allons appliquer dans nos prochaines API :

<ScrollableImage name="architecture.png" minWidth="859px" maxWidth="859px" />
<figcaption>Architecture recommand√©e pour ce cours</figcaption>

Voici quelques explications sur ce diagramme que nous allons appliquer dans le prochain tutoriel :

1. Un client fait la requ√™te √† l'API demandant de lire toutes les pizzas.
2. Le router de "pizzas" prend le r√¥le de "Controller". Il s'occupe de traiter de la requ√™te et d'appeler une op√©ration du **fat model** pour acc√©der aux ressources.
3. Le **fat model** s'occupe d'acc√©der aux donn√©es, qui se trouvent au sein d'un fichier JSON, et de les lire.
4. Le **fat model** retourne des donn√©es sous forme d'un objet JS au router de "pizzas".
5. Le router de "pizzas" renvoient une repr√©sentation JSON de l'objet JS, un array de pizzas, au client.

Dans un nouveau tutoriel, nous allons maintenant faire un refactor de notre API de gestion des pizzas en cr√©ant et utilisant un "fat model".

Au sein de votre repo **`web2`**, √† l'aide du boilerplate du cours [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate), veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/api/fat-model`**.

Si vous ne voyez pas comment utiliser le boilerplate, tout est expliqu√© dans le **`README`** associ√© au repository du boilerplate. N'h√©sitez pas √† le (re)lire ; )

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **`/web2/tutorials/pizzeria/api/fat-model`**.

Nous allons commencer par cr√©er le **fat model** offrant les op√©rations sur les pizzas.   
Veuillez cr√©er le fichier **`/models/pizzas.js`**.  
Au sein de ce fichier, veuillez ajouter le code s'occupant des op√©rations sur les ressources de type "pizzas" :

```js
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jsonDbPath = path.join(__dirname, '/../data/pizzas.json');

const defaultPizzas = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

function readAllPizzas(orderBy) {
  const orderByTitle = orderBy?.includes('title') ? orderBy : undefined;
  let orderedMenu;
  const pizzas = parse(jsonDbPath, defaultPizzas);
  if (orderByTitle)
    orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  const allPizzasPotentiallyOrderd = orderedMenu ?? pizzas;
  return allPizzasPotentiallyOrderd;
}

function readOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const indexOfPizzaFound = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (indexOfPizzaFound < 0) return undefined;

  return pizzas[indexOfPizzaFound];
}

function createOnePizza(title, content) {
  const pizzas = parse(jsonDbPath, defaultPizzas);

  const createdPizza = {
    id: getNextId(),
    title,
    content,
  };

  pizzas.push(createdPizza);

  serialize(jsonDbPath, pizzas);

  return createdPizza;
}

function getNextId() {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const lastItemIndex = pizzas?.length !== 0 ? pizzas.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = pizzas[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

function deleteOnePizza(id) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;
  const deletedPizzas = pizzas.splice(foundIndex, 1);
  const deletedPizza = deletedPizzas[0];
  serialize(jsonDbPath, pizzas);

  return deletedPizza;
}

function updateOnePizza(id, propertiesToUpdate) {
  const idNumber = parseInt(id, 10);
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const foundIndex = pizzas.findIndex((pizza) => pizza.id === idNumber);
  if (foundIndex < 0) return undefined;

  const updatedPizza = { ...pizzas[foundIndex], ...propertiesToUpdate };

  pizzas[foundIndex] = updatedPizza;

  serialize(jsonDbPath, pizzas);

  return updatedPizza;
}

module.exports = {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
};
```

Maintenant, il ne reste plus qu'√† mettre √† jour le router **`/routes/pizzas.js`** afin de faire les appels aux fonctions offertes par le mod√®le :

```js numbered highlighting="1-8,17,24,39,46,62"
const express = require('express');
const {
  readAllPizzas,
  readOnePizza,
  createOnePizza,
  deleteOnePizza,
  updateOnePizza,
} = require('../models/pizzas');

const router = express.Router();

/* Read all the pizzas from the menu
   GET /pizzas?order=title : ascending order by title
   GET /pizzas?order=-title : descending order by title
*/
router.get('/', (req, res) => {
  const allPizzasPotentiallyOrdered = readAllPizzas(req?.query?.order);

  return res.json(allPizzasPotentiallyOrdered);
});

// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  const foundPizza = readOnePizza(req.params.id);

  if (!foundPizza) return res.sendStatus(404);

  return res.json(foundPizza);
});

// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content =
    req?.body?.content?.length !== 0 ? req.body.content : undefined;

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const createdPizza = createOnePizza(title, content);

  return res.json(createdPizza);
});

// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  const deletedPizza = deleteOnePizza(req.params.id);

  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  const title = req?.body?.title;
  const content = req?.body?.content;

  if ((!title && !content) || title?.length === 0 || content?.length === 0) {
    return res.sendStatus(400);
  }

  const updatedPizza = updateOnePizza(req.params.id, { title, content });

  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});

module.exports = router;
```

Lancer votre API soit via le debugger, soit via la commande **`npm run dev`**.  
Veuillez ensuite tester que tout fonctionne bien en ex√©cutant les requ√™tes HTTP d√©j√† pr√©sentes dans le r√©pertoire **`REST Client`** du boilerplate.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message : **`fat-model tutorial`**.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

# <InternalPageTitle> Exercice 1.9 : Refactoring √† l'aide d'un fat model </InternalPageTitle>

Vous allez faire un nouveau refactor de la RESTful API de **myMovies**, afin de restructurer l'application selon l'architecture recommand√©e, en utilisant un "fat model" pour g√©rer les op√©rations sur les films.

Veuillez repartir du code de la solution de votre [Exercice 1.8](../tools/#exercice_1_8_refactoring_a_laide_de_linter_formatter).  
Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.9`**. 

Veuillez faire un refactor de votre API g√©rant les films afin que tout ce qui traite des op√©rations sur les ressources soit fait au sein du mod√®le **`/models/films.js`**.

Veuillez tester que votre API fonctionne toujours aussi bien apr√®s le refactoring.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.9 : API : fat model`**.


# <InternalPageTitle> Exercice 1.10 : Encore un fat model </InternalPageTitle>

Vous allez cr√©er une nouvelle API mettant √† disposition des op√©rations CRUD (**C**reate, **R**ead, **U**pdate & **D**elete) sur des ressources de type "texte √† dactylographier". 

Vous devez appliquer les outils de d√©veloppement et l'architecture recommand√©e dans ce cours-ci en mettant en place un "fat model".

Pour ce faire, veuillez cr√©er un nouveau projet dans votre repository local et votre web repository (normalement appel√© **`web2`**) nomm√© **`/exercises/1.10`** sur base du boilerplate : [basic-api-boilerplate](https://github.com/e-vinci/basic-api-boilerplate).

‚ö° Si vous avez fait un clone du boilerplate, attention au Git dans le Git, n'oubliez pas de supprimer le dossier **`.git`** pr√©sent dans votre nouveau projet.

Un texte √† dactylographier contient comme propri√©t√©s : 
- **`id`** : un entier ;
- **`content`** : un contenu textuel ;
- **`level`** : le niveau associ√© au texte; les seules valeurs autoris√©es sont : **easy**, **medium** et **hard**.

Voici le tableau formalisant toutes les op√©rations que vous devez impl√©menter :

| URI |	M√©thode |	M√©thode |
|-----|---------|-----------|
| **`texts`**	| GET |	READ ALL : Lire toutes les ressources de la collection |
| **`texts?level=value`**	| GET |	READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`texts/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`texts`**	| POST	| CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`texts/{id}`** |	DELETE	| DELETE ONE : Effacer la ressource identifi√©e |
| **`texts/{id}`** |	PUT	| UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Veuillez bien valider les valeurs des param√®tres. Notament, une **`level`** doit √™tre compris dans les valeurs autoris√©es, sinon un code d'erreur appropri√© doit √™tre renvoy√©.

Veuillez tester toutes les m√©thodes offertes par votre application √† l'aide du client HTTP 
de REST Client.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.10 : API : CRUD texts & fat model`**.