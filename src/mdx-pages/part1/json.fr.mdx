---
title: "JSON"
description: "Introduction au JSON et persistance des donn√©es"
---

# b) Introduction au JSON et persistance des donn√©es

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1 </PathViewerItem>
    <PathViewerItem selected> b) JSON </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Le JSON, c'est quoi ? </InternalPageMenuItem>
  <InternalPageMenuItem> Communication de donn√©es en JSON √† une API </InternalPageMenuItem>
  <InternalPageMenuItem> Lecture et sauvegarde de donn√©es dans un fichier JSON par une API </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 1.7 : Persistance des donn√©es </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Le JSON, c'est quoi ? </InternalPageTitle>

Pr√©c√©demment, nous avons d√©velopp√© notre premi√®re RESTful API.  
Nous avons implicitement d√©couvert le JSON, notamment lorsque nous avons fait des requ√™tes vers nos API.

Nous allons maintenant voir ce que permet le JSON, notamment la cr√©ation de fichiers permettant de sauvegarder des donn√©es facilement en JS.

**JSON** vient de **J**ava**S**cript **O**bject **N**otation.

C'est une syntaxe pour **√©changer** et **faire persister des donn√©es**.

Du JSON, c'est du texte en notation JS.

Voici les types de donn√©es qui sont valides en JSON :

- **`string`**
- **`number`**
- **`object`**
- **`array`**
- **`boolean`**
- **`null`**

‚ö° Il n'y a donc pas de **`function`**, **`date`** et **`undefined`**.

Voici un exemple de repr√©sentation de donn√©es en JSON qui correspond √† ce que tr√®s souvent une API renvoie, un array d'objets :

```json
[
  {
    "email": "raphael@voila.com",
    "fullname": "Raphael Baroni"
  },
  {
    "email": "jkj@herenqn.com",
    "fullname": "JK Roling"
  },
  {
    "email": "serena@gmail.com",
    "fullname": "Serena Here"
  }
]
```

# <InternalPageTitle> Communication de donn√©es en JSON √† une API </InternalPageTitle>

## Introduction
Dans le tutoriel pr√©c√©dent, nous avons communiqu√© des donn√©es au format JSON :
- soit lors des requ√™tes via REST Client : nous avons envoy√© les donn√©es permettant de cr√©er ou modifier une pizza :
- soit lors du traitment des requ√™tes par l'API, afin de cr√©er ou modifier les pizzas et les sauvegarder en m√©moire vive (dans un tableau d'objets).

Nous allons maintenant approfondir comment les donn√©es au format JSON ont √©t√© trait√©es par l'API.

## Envoi de donn√©es d'une API vers un client & s√©rialisation

Via Express, nous pouvons tr√®s facilement convertir un objet JS en JSON afin de l'envoyer vers une application cliente gr√¢ce √† la m√©thode **`res.json()`**.

C'est ce que nous appelons de la **s√©rialisation** de donn√©es : nous passons du monde "objets en m√©moire" vers du texte (ou des octets) qui va voyager sur un r√©seau.

Le code actuel de notre RESTful API, renvoyant un array de pizzas au format JSON, est g√©r√© automatiquement via :

```js
res.json(orderedMenu ?? MENU);
```

Lorsque l'API renvoie **`MENU`** avec les pizzas par d√©faut, voici le JSON qui voyage sur le r√©seau :

```json
[
  {
    "id": 1,
    "title": "4 fromages",
    "content": "Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates"
  },
  {
    "id": 2,
    "title": "Vegan",
    "content": "Tomates, Courgettes, Oignons, Aubergines, Poivrons"
  },
  {
    "id": 3,
    "title": "Vegetarian",
    "content": "Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives"
  },
  {
    "id": 4,
    "title": "Alpage",
    "content": "Gruy√®re, Mozarella, Lardons, Tomates"
  },
  {
    "id": 5,
    "title": "Diable",
    "content": "Tomates, Mozarella, Chorizo piquant, Jalapenos"
  }
]
```

üí≠ La puissance du JSON peut d√©j√† s'exprimer ici. Mais comment ?

L'API renvoie un array d'objets, des pizzas, au format JSON, qui correspond en fait √† un format texte avec des conventions.  
Il est donc possible √† n'importe quelle application cliente d'utiliser ces donn√©es, quelque soit la technologie, le langage utilis√© pour d√©velopper cette application cliente.   
Ainsi, par exemple, une application Android, d√©velopp√©e en Java, pourrait consommer cette API pour afficher un menu de pizzas !

## R√©ception de donn√©es d'un client par une API & parsing

Via Express, nous pouvons tr√®s facilement convertir du JSON vers un objet JS √† l'aide du middleware **`express.json()`**.

C'est ce que nous appelons du **parsing** de donn√©es, ou de la **d√©s√©rialisation** : nous passons du monde texte / JSON (ou des octets) vers des "objets en m√©moire".

Le code actuel de notre RESTful API, r√©cup√©rant les donn√©es d'une pizza √† cr√©er, est tr√®s simple :

```js
const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;
```

Automatiquement, gr√¢ce √† Express et au middleware appel√© dans **`apps.js`** (**`app.use(express.json());`**), **`req.body`** contient un objet JS repr√©sentant toutes les donn√©es JSON qui √©taient pr√©sentes dans le body de la requ√™te cliente, comme par exemple :

```http highlighting="5-8"
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Il est important de communiquer le "**media type**" (ou **MIME type**) dans le corps de la requ√™te : **`application/json`**.  
Cela indique √† l'application qui est la cible de la requ√™te (l'API dans notre cas) quelle genre d'outil elle devra utiliser pour d√©coder les donn√©es.  
Par exemple, il faut faire un traitement diff√©rent pour r√©cup√©rer des donn√©es au format JSON que pour r√©cup√©rer des donn√©es directement associ√©es √† un fichier image.

# <InternalPageTitle> Lecture et sauvegarde de donn√©es dans un fichier JSON par une API </InternalPageTitle>

## Lecture de donn√©es se trouvant dans un fichier JSON

La fonction **`JSON.parse(objectSerialized) `** permet de cr√©er un objet JS √† partir d'une **`string`** contenant des donn√©es au format JSON.

Par exemple, voici une fonction, permettant √† une application Express de cr√©er un objet JS en lisant des donn√©es se trouvant dans un fichier **`.json`** dont le chemin et nom complet sont indiqu√©s dans le param√®tre **`filePath`** :

```js
/**
 * Parse items given in a .json file
 * @param {String} filePath - path to the .json file
 * If the file does not exist or it's content cannot be parsed as JSON data,
 * use the default data.
 * @param {Array} defaultArray - Content to be used when the .json file does not exists
 * @returns {Array} : the array that was parsed from the file (or defaultData)
 */
function parse(filePath, defaultArray = []) {
  if (!fs.existsSync(filePath)) return defaultArray;
  const fileData = fs.readFileSync(filePath);
  try {
    // parse() Throws a SyntaxError exception if the string to parse is not valid JSON.
    return JSON.parse(fileData);
  } catch (err) {
    return defaultArray;
  }
}
```

Imaginez que plut√¥t que de lire le menu de pizza √† partir d'un array d'objets, on souhaite lire ce menu gr√¢ce au contenu d'un fichier contenant du JSON. Voici ce que donnerait l'op√©ration de lecture de toutes les pizzas si le chemin et nom complet du fichier JSON √©tait donn√© dans la constante **jsonDbPath**. :

```js
const jsonDbPath = __dirname + '/../data/pizzas.json';
// Read all the pizzas from the menu
router.get('/', function (req, res) {
  console.log('GET /pizzas');
  const pizzas = parse(jsonDbPath, DEFAULT_MENU);
  res.json(pizzas);
});
```

## Sauvegarde de donn√©es dans un fichier JSON

La fonction **`JSON.stringify(objectToSerialised)`** permet de cr√©er une **`string`** contenant la repr√©sentation JSON de l'objet √† s√©rialiser.

C√¥t√© serveur, il est ensuite facile de sauvegarder les donn√©es JSON au sein d'un fichier.

Par exemple, voici une fonction permettant √† une application Express de sauvegarder au format JSON un objet dans un fichier **`.json`** dont son chemin et nom complet sont indiqu√©s dans le param√®tre **`filePath`** :

```js
/**
 * Serialize the content of an Object within a file
 * @param {String} filePath - path to the .json file
 * @param {Array} object - Object to be written within the .json file.
 * Even if the file exists, its whole content is reset by the given object.
 */
function serialize(filePath, object) {
  const objectSerialized = JSON.stringify(object);
  fs.writeFileSync(filePath, objectSerialized);
}
```

Imaginez que, au sein du router traitant des ressources de type "pizzas", vous passiez la valeur suivante √† **`filePath`** :

```js
const jsonDbPath = __dirname + '/../data/pizzas.json';
serialize(jsonDbPath, MENU);
```

Cela signifie que dans le projet contenant notre API, nous allons sauvegarder le menu des pizzas au format JSON dans le fichier JSON **`/data/pizzas.json`**.

Ce fichier est en fait une **base de donn√©es simplifi√©e** !  

## Persistance des donn√©es : d'une sauvegarde en m√©moire vive vers un fichier JSON

Nous allons maintenant r√©aliser un tutoriel pour rendre les ressources de type "pizzas" persistantes.  
Nous allons repartir de l'API cr√©√©e au tutoriel pr√©c√©dent.

Dans votre repo **`web2`**, veuillez copier / coller le r√©pertoire **`/tutorials/pizzeria/api/basic`** et le renommer en **`/tutorials/pizzeria/api/persistence`**.

En cas de souci, vous pouvez t√©l√©charger le code du tutoriel pr√©c√©dent ici : [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **`/tutorials/pizzeria/api/persistence`** (ou **`/web2/tutorials/pizzeria/api/persistence`** si l'on consid√®re le nom du r√©pertoire du repo).

Veuillez cr√©er un nouveau r√©pertoire **`/utils`**. Au sein de ce r√©pertoire, veuillez cr√©er le module **`/utils/json.js`** dans lequel vous allez ajouter ces fonctions :

```js
const fs = require('fs');

/**
 * Parse items given in a .json file
 * @param {String} filePath - path to the .json file
 * If the file does not exist or it's content cannot be parsed as JSON data,
 * use the default data.
 * @param {Array} defaultArray - Content to be used when the .json file does not exists
 * @returns {Array} : the array that was parsed from the file (or defaultArray)
 */
function parse(filePath, defaultArray = []) {
  if (!fs.existsSync(filePath)) return defaultArray;
  const fileData = fs.readFileSync(filePath);
  try {
    // parse() Throws a SyntaxError exception if the string to parse is not valid JSON.
    return JSON.parse(fileData);
  } catch (err) {
    return defaultArray;
  }
}

/**
 * Serialize the content of an Object within a file
 * @param {String} filePath - path to the .json file
 * @param {Array} object - Object to be written within the .json file.
 * Even if the file exists, its whole content is reset by the given object.
 */
function serialize(filePath, object) {
  const objectSerialized = JSON.stringify(object);
  createPotentialLastDirectory(filePath);
  fs.writeFileSync(filePath, objectSerialized);
}

/**
 *
 * @param {String} filePath - path to the .json file
 */
function createPotentialLastDirectory(filePath) {
  const pathToLastDirectory = filePath.substring(0, filePath.lastIndexOf('/'));

  if (fs.existsSync(pathToLastDirectory)) return;

  fs.mkdirSync(pathToLastDirectory);
}

module.exports = { parse, serialize };
```


L'op√©ration de s√©rialisation des donn√©es est faite via la fonction **`serialize`** de **`/utils/json.js`**. Pour se simplifier la vie et ne pas obliger les d√©veloppeurs √† devoir cr√©er manuellement un r√©pertoire qui contiendra la mini DB de pizzas (le fichier **`pizzas.json`** dans la suite de l'exemple), une fonction a √©t√© cr√©√©e qui s'appelle **`createPotentialLastDirectory`**.  
La fonction **`serialize`** fait appel √† cette fonction qui va, si n√©cessaire, cr√©er le dernier r√©pertoire donn√© dans le chemin vers le fichier JSON (le r√©pertoire **`/data`** dans la suite de l'exemple).

Il n'est pas int√©ressant de retenir par coeur le code donn√© dans **`/utils/json.js`**. Par contre, il est important que vous compreniez celui-ci, ce qu'il fait.

A pr√©sent, nous allons convertir le code du router de "pizzas" pour rendre les donn√©es peristantes.    
Voici ce que nous devons faire pour les op√©rations de :
- **lecture de ressources** : il suffit de faire appel √† la fonction **`parse`** qui tentera de charger les ressources qui devraient se trouver dans le r√©pertoire **`/data/pizzas.json`**. Notons que le chemin vers ce fichier JSON est un simple choix, il doit √™tre configurable.
- **√©criture de ressources** : lors d'une op√©ration d'√©criture pour cr√©er une nouvelle ressource, ou pour mettre √† jour une ressource existante, voici les √©tapes :
  - cr√©ation d'une liste de toutes les pizzas dans un array : cela correspond √† l'utilisation de la fonction **`parse`** pour tenter de charger ce qui est contenu dans la mini DB de pizzas.
  - mise √† jour de l'array soit en ajoutant un nouvel objet (une pizza), soit en modifiant un objet existant, soit en supprimant un objet.
  - r√©√©criture compl√®te du fichier JSON contenant la liste de pizzas sur base de l'array de pizzas qui a pr√©c√©demment √©t√© mis √† jour via la m√©thode **`serialize`**.

Voici le code du router mis √† jour afin de g√©rer la persistance selon la strat√©gie d√©finie ci-dessus, les modifications √©tant surlign√©es :

```js numbered highlighting="2,5,45,47,51,58,60,64,76-78,87,89,98,100,104,107,123,125,129,131,133"
var express = require('express');
const { serialize, parse } = require('../utils/json');
var router = express.Router();

const jsonDbPath = __dirname + '/../data/pizzas.json';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title') ? req.query.order : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);

  const pizzas = parse(jsonDbPath, MENU);
  
  if (orderByTitle) orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  return res.json(orderedMenu ?? pizzas);
});

// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const pizzas = parse(jsonDbPath, MENU);

  const indexOfPizzaFound = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.sendStatus(404);

  return res.json(pizzas[indexOfPizzaFound]);
});

// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const pizzas = parse(jsonDbPath, MENU);
  const lastItemIndex = pizzas?.length !== 0 ? pizzas.length - 1 : undefined;
  const lastId = lastItemIndex !== undefined ? pizzas[lastItemIndex]?.id : 0;
  const nextId = lastId + 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  pizzas.push(newPizza);

  serialize(jsonDbPath, pizzas);

  return res.json(newPizza);
});

// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  console.log(`DELETE /pizzas/${req.params.id}`);

  const pizzas = parse(jsonDbPath, MENU);

  const foundIndex = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const itemsRemovedFromMenu = pizzas.splice(foundIndex, 1);
  const itemRemoved = itemsRemovedFromMenu[0];

  serialize(jsonDbPath, pizzas);

  return res.json(itemRemoved);
});

// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  console.log(`PATCH /pizzas/${req.params.id}`);

  const title = req?.body?.title;
  const content = req?.body?.content;

  console.log('POST /pizzas');

  if ((!title && !content) || title?.length === 0 || content?.length === 0) return res.sendStatus(400);

  const pizzas = parse(jsonDbPath, MENU);

  const foundIndex = pizzas.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const updatedPizza = {...pizzas[foundIndex], ...req.body};

  pizzas[foundIndex] = updatedPizza;

  serialize(jsonDbPath, pizzas);

  return res.json(updatedPizza);
});

module.exports = router;
```

Veuillez mettre √† jour votre fichier **`/router/pizzas.js`** sur base du code donn√© et testez le bon fonctionnement de l'application. Faites quelques requ√™tes pour ajouter et modifier des donn√©es et v√©rifiez, une fois que vous red√©marrer votre application, que les donn√©es persistent.


# <InternalPageTitle> Exercice 1.7 : Persistance des donn√©es </InternalPageTitle>

Vous allez mettre √† jour la RESTful API de **myMovies** afin de rendre les donn√©es persistantes dans un fichier JSON : **`/data/films.json`**.

Veuillez repartir du code de la solution de votre [Exercice 1.6](../express-api/#exercice_1_6_suppression_modification_de_ressources).  
Le code de votre application doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/exercises/1.7`**.  

Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide de REST Client en copiant les requ√™tes d√©velopp√©es pour l'exercice pr√©c√©dent (fichier **films.http** du r√©pertoire **REST Client**). Normalement, il n'y a pas de nouvelles requ√™tes √† √©crire, il suffit juste de les ex√©cuter.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.7 : API : persistence`**.