---
title: "S√©curit√© du browser"
description: "S√©curit√© des communications du browser"
---

# k) S√©curit√© des communications du browser

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> k) S√©curit√© des communications du browser </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Single Origin Policy & CORS </InternalPageMenuItem>
  <InternalPageMenuItem> Autorisation d'origines & les CORS </InternalPageMenuItem>
  <InternalPageMenuItem> Simulation d'une m√™me origine via un proxy </InternalPageMenuItem>
  <InternalPageMenuItem> Projet 2.17 : consommation d'op√©rations d'une API √† l'aide d'un proxy  </InternalPageMenuItem>
  <InternalPageMenuItem> Project 2.18 : Autorisation de nouvelles origines </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Single Origin Policy & CORS </InternalPageTitle>

La **Single Origin Policy** (**SOP**) sont des r√®gles appliqu√©es par le browser afin :
- de restreindre les interactions entre un document ou script charg√© par une origine avec une ressource d'une autre origine ;
- d'isoler des documents ou scripts malicieux, afin de r√©duire le risque des attaques.

Deux URL ont une m√™me **origine** si ces caract√©ristiques sont les m√™mes :

- **protocole** ;
- **port** ;
- **host** ; l'URL pointe vers le m√™me appareil connect√© √† internet ou √† un r√©seau local.

Il est possible de relaxer la s√©curit√© via des **Cross Origin Resource Sharing** (**CORS**).  
**CORS** est un m√©canisme qui utilise des headers HTTP pour indiquer aux browsers qu'ils peuvent autoriser les acc√®s √† des ressources d'origines diff√©rentes.

Cela signifie qu'une application web qui utilise une API ne peut le faire que si les ressources demand√©es √† l'API proviennent d'une m√™me origine, √† moins que la r√©ponse de l'API inclut les bonnes **CORS** (via des header HTTP).

Si l'on autorise trop d'origines, voici un exemple classique d'attaque :

<ScrollableImage name="cors-issue.png" minWidth="500px" maxWidth="700px" />

Imaginez qu'un site d'une banque ne soit pas s√©curis√© avec des techniques modernes. Ce site utiliserait une IHM (**`https://my-bank.com`**), qui, via un formulaire, permettrait de faire un versement, sous r√©serve d'envoyer un cookie qui contiendrait une variable de session (simple m√©canisme de s√©curit√©) lors d'une requ√™te √† l'API de la banque.

Maintenant, prenons le cas d'un utilisateur qui adore jouer sur le web, un gamer en puissance. Il joue √† un jeu de pinguins, mais soudainement, il est redirig√© vers un site malicieux (**`https://malicious.com`**), qui lui offre un nouveau jeu avec des dinosaures. Ce site malicieux, en arri√®re plan, pourrait faire une requ√™te vers la m√™me API utilis√©e par **`https://my-bank.com`**.  
Comme c'est le m√™me browser utilis√© par notre gamer, tant pour faire ses virements, que pour jouer, toute requ√™te faite vers **`https://api.my-bank.com`** enverra d'office les cookies existants et associ√©s au domaine **`api.my-bank.com`**.
Les r√©sultats peuvent √™tre dramatiques : l'attaquant √† la capacit√© de faire des versements jusqu'√† vider le compte de notre pauvre gamer.

Bien s√ªr, gr√¢ce √† la **SOP** appliqu√©e par nos browser, par d√©faut, d√®s que le site malicieux communique avec l'API de la banque, celui-ci bloque l'acc√®s aux ressources de l'API car l'origine du site malicieux est diff√©rente de l'origine de l'API.

Les **CORS** permettent de rel√¢cher la s√©curit√©, afin notamment, dans le sc√©nario √©voqu√©, d'autoriser l'origine **`https://my-bank.com`** √† acc√©der √† l'origine **`https://api.my-bank.com`**. En effet, c'est ce que le site de la banque souhaite.  
Par contre, si la banque poss√®de des d√©veloppeurs nuls au niveau s√©curit√© et que ceux-ci autorisent toutes les origines √† interroger l'API, l√†, nous pourrions arriver au hacking d√©crit ci-dessus.

Nous allons voir comment nous pouvons communiquer entre un frontend et une API fonctionnant sous deux origines diff√©rentes, √† l'aide de deux techniques diff√©rentes.

# <InternalPageTitle> Autorisation d'origines & les CORS </InternalPageTitle>

A cette partie-ci, nous allons voir comment mettre √† jour une API afin que dans chaque r√©ponse faite √† un client, on ajoute un header permettant d'autoriser une ou plusieurs origines.

Pour ce nouveau tutoriel, nous allons partir de la derni√®re version de la RESTful API de pizzas.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/api/cors`** sur base d'un copi√© coll√© de **`/web2/tutorials/pizzeria/api/fat-model`** (ou [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/api/cors`**.

Dans ce projet, veuillez installer le package **`cors`** :

```bash
npm i cors
```

Nous allons configurer les headers de la RESTful API √† l'aide du middleware **cors** offert par
la librairie **cors**.

Pour configurer et utiliser les **CORS**, veuillez mettre √† jour le fichier **`/app.js`** :

```js numbered highlighting="4-8,21"
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const cors = require('cors');

const corsOptions = {
  origin: 'http://localhost:8080',
};

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');

const app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', cors(corsOptions), pizzaRouter);

module.exports = app;
```

Ici, nous pr√©cisons que l'API doit autoriser l'origine associ√©e au port sur lequel tourne
le serveur de fichiers statiques de Webpack (**`8080`**). Notons que nous n'avons pas rel√¢ch√© la s√©curit√© pour les ressources de type "users", la fonction middleware **`cors`** n'est pas appel√©e au niveau du router de pizza.

Veuillez stopper l'√©ventuelle ancienne version de l'API, si elle est ex√©cut√©e, et d√©marrer votre nouvelle version de l'API (**`/web2/tutorials/pizzeria/api/cors`**).

Il vous reste √† vous assurer que votre frontend (**`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`**) est lui aussi bien d√©marr√© et peut r√©aliser son fetch impl√©ment√© dans **`HomePage.js`**.

Tout fonctionne correctement ?

Normalement oui, vous devriez avoir le site de la pizzeria qui affiche le menu des pizzas suite √† un appel √† l'API.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message :
**`api-cors tutorial`**.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
- pour l'API : [api-cors](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cors).
- pour le frontend :
  [basic-fetch-no-proxy-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch-no-proxy).

üí≠ OK, √ßa fonctionne bien... Mais cela est possible seulement si nous sommes les propri√©taires de la RESTful API. Maintenant, que faire si une API tierce doit √™tre int√©gr√©e dans notre frontend ?  
Imaginez que vous souhaitez int√©grer une op√©ration d'une API offerte par Google...  
Pensez-vous que vous pouvez leur donner un coup de fil et dire : *"Google, peux-tu STP autoriser l'origine associ√©e √† mon site web ?"...*  
Nous allons voir un autre moyen de contourner la **SOP** (Single Origin Policy) impos√©e par le browser.

# <InternalPageTitle> Simulation d'une m√™me origine via un proxy </InternalPageTitle>

Il est possible de mettre en place un proxy au niveau du frontend afin de faire croire au browser que l'API et le frontend ont la m√™me origine.

Ici, nous sommes dans la situation o√π nous ne souhaitons pas, ou nous n'avons pas les moyens, d'ajouter des origines au niveau de l'API.

Veuillez stopper l'ex√©cution de l'API (**`/web2/tutorials/pizzeria/api/cors`**) et du frontend (**`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`**).

Veuillez d√©marrer l'API qui n'autorise aucune autre origine : **`/web2/tutorials/pizzeria/api/fat-model`** (ou via le code de ce web repo si vous avez un souci : [api-fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model)).

Nous allons mettre en place un m√©canisme au niveau du frontend pour faire passer toutes les requ√™tes √† destination de l'API par un proxy ; le proxy aura la m√™me origine que le serveur de fichiers statiques ayant offert le frontend.

Pour ce nouveau tutoriel, au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/basic-fetch`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`** (ou [basic-fetch-no-proxy-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch-no-proxy)).

Il vous reste aussi √† vous assurer que votre frontend (**`/web2/tutorials/pizzeria/hmi/basic-fetch`**) est lui aussi bien d√©marr√©. Il devrait toujours y avoir l'erreur associ√©e aux **CORS** donn√©e au sein de la console.

Voici le workflow que nous allons appliquer √† notre site g√©rant la pizzeria :

<ScrollableImage name="proxy.png" minWidth="691px" maxWidth="691px" />
<figcaption>Redirections des requ√™tes via un proxy</figcaption>

Gr√¢ce √† ce diagramme, on voit comment mettre √† jour le tutoriel pr√©c√©dent qui affichait une erreur au niveau des **CORS** : on va faire une requ√™te GET vers **`/api/pizzas`** et non plus vers **`http://localhost:3000/pizzas`**.

Le serveur de d√©veloppement de Webpack met √† disposition un proxy. Celui-ci est d'ailleurs configur√© ainsi dans le boilerplate (voir fichier **`./webpack.config.js`**) :

```js
proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
```

Cela signifie qu'√† chaque fois qu'une requ√™te sera faite sur **`/api`** (on reste sur la m√™me origine que le serveur de fichiers statiques, **`8080`** tel que configur√© dans **`./webpack.config.js`** du boilerplate), celle-ci sera redirig√©e vers le port **`3000`**, le port de l'API.
Le **`pathRewrite`** permet de ne pas reprendre **`/api`** dans l'URL de la redirection :
**`GET /api/pizzas`** devient **`GET http://localhost:3000/pizzas`**.

Dans le code du tutoriel en cours (**`/web2/tutorials/pizzeria/hmi/basic-fetch`**), veuillez mettre √† jour l'URL au niveau du **`fetch`** dans **`HomePage.js`** :

```js numbered highlighting="4"
const HomePage = () => {
  clearPage();

  fetch('/api/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
      attachOnMouseEventsToGoGreen();
      renderDrinksFromNodes(DRINKS);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });
};
```

A ce stade-ci, tout devrait fonctionner : le menu des pizzas est affich√© suite √† l'appel √† notre RESTful API ne relaxant pas la s√©curit√© !

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message :
**`basic-fetch-hmi with proxy tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [basic-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).
- pour l'API : [api-fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

üç¨ Voici quelques infos non capitales pour ce cours-ci :

- Il existe une multitude de proxy pour un environnement de d√©veloppement : **`Webpack devServer`** et son proxy, **`VS Code proxy`**, proxy l√©ger de **`Node`** directement configurable via **`package.json`** (**`"proxy": "http://localhost:3000",`**), ...
- Il existe par exemple un proxy complet sous Node : **`http-proxy-middleware`**.
- Pour la production, lorsque vous d√©ployer une application web sur le cloud, il faudra trouver les instructions de votre provider pour voir comment configurer le proxy.  
  Par exemple, pour configurer un **static file server** et son **proxy** sous **heroku** (provider de services d'h√©bergements sur le cloud), il faut configurer le fichier **`/static.json`**.

üí≠ Que pensez-vous du code associ√© aux t√¢ches asynchrones, afin de cha√Æner des actions suite au **`fetch`** ?  
Ca n'est pas des plus lisibles... imaginez que vous ayez des tonnes de **`.then()`** √† g√©rer, dans lesquels vous allez aussi faire appel √† des fonctions asynchrones... Ca deviendra vite compliqu√© comme code.

Nous allons donc tout prochainement voir comment rendre la programmation asynchrone plus l√©g√®re, √† l'aide de promesses et de **`async`** / **`await`**.


# <InternalPageTitle> Projet 2.17 : consommation d'op√©rations d'une API √† l'aide d'un proxy  </InternalPageTitle>

Veuillez enrichier la SPA d√©velopp√©e dans le cadre de votre projet en lui ajoutant :
- Une RESTful API offrant une op√©ration de lecture sur des ressources ;
- Une page √† votre frontend pour afficher les ressources offertes par l'op√©ration de lecture de la RESTful API.

Dans un premier temps, identifiez le type de ressources qui aurait du sens √† √™tre affich√©e dans votre SPA.
Cela sera peut-√™tre des ressources de type "√©v√©nements", "utilisateurs", "scores", "recettes"...

Vous allez donc d√©velopper deux applications :
- Pour votre frontend : veuillez repartir du code de [Projet 2.14](../animations/#projet_2_14_animation).  
Le code du frontend doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.17/frontend`**.
- Pour votre API : le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.17/api`**.

<UnAuthenticatedBlock>

Si vous avez choisi comme projet de travailler sur l'application **`myMovies`**, alors :
- vous pouvez directement utiliser votre API existante d√©velopp√©e pour l'[Exercice 1.10](../../part1/refactoring/#exercice_1_10_encore_un_fat_model).
- pour le frontend, vous allez simplement mettre √† jour la **`ViewMoviePage`** afin de consommer l'op√©ration de lecture de films de l'API pour afficher tous les films.

</UnAuthenticatedBlock>

<AuthenticatedBlock>

Veuillez travailler avec les membres de votre groupe.  
Il est int√©ressant que vous vous partagiez le travail :
- certains membres de l'√©quipe travail sur le d√©veloppement de l'API ;
- les autres travaillent sur le frontend.

Quand vous travaillez sur le code de votre projet, vous pouvez aussi directement travailler sur le web repo de votre groupe. Dans ce cas-ci, vous devriez cr√©er deux "feature branches" : 
- une pour l'API ;
- une pour le frontend.

Une fois que vos prototypes sont pr√™ts, vous pouvez "merger" vos "feature branches" √† la branche principal du web repo de votre groupe.

N√©anmoins, il peut √™tre int√©ressant de d'abord fournir un prototype de votre code dans votre web repo personnel au sein de **`/project/2.17/frontend`** et **`/project/2.17/api`**.

Quand un prototype d'api est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`2.17 : api read operation`**.

</AuthenticatedBlock>

Au niveau du frontend, vous devez afficher des ressources offertes par une op√©ration de lecture de votre API, **en utilisant le proxy offert par webpack** !

Quand un prototype de frontend est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`2.17 : frontend basic proxy to render ressources`**.


# <InternalPageTitle> Project 2.18 : Autorisation de nouvelles origines </InternalPageTitle>

Vous devez mettre √† jour l'API d√©velopp√©e pour [Project 2.17](#projet_2_17_consommation_doperations_dune_api_a_laide_dun_proxy) afin d'autoriser les origines locales fonctionnant sur ces ports : **`8080`**, **`7000`** et **`666`**.

Vous devez aussi mettre √† jour le frontend d√©velopp√© pour [Project 2.17](#projet_2_17_consommation_doperations_dune_api_a_laide_dun_proxy) pour ne plus utiliser le proxy du frontend. Vous consommez directement l'API en indiquant son URL compl√®te, y compris le port.  
*Par exemple, si vous traitiez de ressources de type "films", vous devez faire un **`fetch`** avec comme URL : **`http://localhost:3000/films`**.*

Vous allez donc adapter deux applications :
- Pour votre frontend : veuillez repartir du code de [Project 2.17](#projet_2_17_consommation_doperations_dune_api_a_laide_dun_proxy).  
Le code du frontend doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.18/frontend`**.
- Pour votre API : veuillez aussi repartir du code de [Project 2.17](#projet_2_17_consommation_doperations_dune_api_a_laide_dun_proxy). Le code doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/2.18/api`**.

Quand un prototype d'api est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`2.18 : api with new origins`**.

Quand un prototype de frontend est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`2.18 : frontend render ressources with no proxy`**.