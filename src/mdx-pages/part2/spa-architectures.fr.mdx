---
title: "SPA"
description: "Les SPA, architectures & communications"
---

# j) Les SPA, architectures & communications

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> j) Les SPA, architectures & communications </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Architectures classiques d'applications web </InternalPageMenuItem>
  <InternalPageMenuItem> Caract√©ristiques et workflow associ√©s √† une SPA </InternalPageMenuItem>
  <InternalPageMenuItem> Architectures associ√©es √† une SPA </InternalPageMenuItem>
  <InternalPageMenuItem> Communications au sein d'une SPA </InternalPageMenuItem>
  <InternalPageMenuItem> Requ√™tes asynchrones & les promesses </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 2.15 : Consommation de blagues online  </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.16 : Consommation de questions localement  </InternalPageMenuItem> 
</InternalPageMenu>

# <InternalPageTitle> Architectures classiques d'applications web </InternalPageTitle>

## Introduction

Il existe quelques architectures classiques d'applications web frontend / backend :

- Les Multi Page Applications (MPA) : le serveur est responsable de g√©n√©rer l'HTML et de le renvoyer aux clients ;
- Les Single Page Applications (SPA) : le serveur met √† disposition des op√©rations sur des donn√©es aux clients via des web services ; les clients sont principalement responsables de g√©n√©rer l'HTML. Les web services peuvent prendre plusieurs formes :
  - RESTful API
  - GraphQL
  - WebSocket
  - ...
- ...

## Multi Page Applications

Voici une repr√©sentation d'une MPA tel que vous l'avez potentiellement d√©j√† impl√©ment√©e :

<ScrollableImage name="mpa.png" minWidth="400px" maxWidth="600px" />

<figcaption>MPA communiquant avec un web service</figcaption>

A chaque demande d'une page par un client correspond g√©n√©ralement une requ√™te HTTP de type `GET` faite par un browser :

- le client est mis en attente jusqu'√† ce qu'il re√ßoive la page HTML correspondant √† sa requ√™te ;
- le browser affiche l'HTML re√ßu par le serveur.

Il existe d'autres types d'architectures associ√©es √† des MPA, comme par exemple :

<ScrollableImage name="mpa-api.png" minWidth="600px" maxWidth="800px" />

<figcaption>MPA communiquant avec un web service</figcaption>

Dans cet exemple, le serveur, pour pouvoir g√©n√©rer de l'HTML, va devoir utiliser des op√©rations mises √† disposition par un web service.

Les MPA ne seront pas vue dans ce cours.

## Single Page Applications

Voici une repr√©sentation d'une SPA :

<ScrollableImage name="spa.png" minWidth="600px" maxWidth="800px" />

<figcaption>
  SPA communiquant avec un web service
</figcaption>

Dans un premier temps, la premi√®re requ√™te d'un client est g√©n√©ralement une requ√™te HTTP de type `GET` faite par un browser. L'application web agit comme un serveur de fichiers statiques et va renvoyer le layout HTML de base au browser.
Notons que le browser, une fois le layout HTML de base re√ßu, va demander √† l'application web l'ensemble des fichiers n√©cessaires au bon fonctionnement de l'application : fichiers JS, CSS, images... On appelle ces fichiers les "assets".

A chaque future demande d'un client pour afficher une page, le browser va faire appel de mani√®re asynchrone √† des op√©rations offertes par une web service.

Comme cet appel est asynchrone, l'IHM du browser reste disponible pour des interactions avec l'utilisateur. Une fois la r√©ponse re√ßue du web service, le browser s'occupe de mettre √† jour dynamiquement l'HTML du browser.

## Autres types d'architectures web

Il existe bien s√ªr d'autres types d'architectures web que celles pr√©sent√©es ci-dessus.

Vous pourrez explorer par vous-m√™me, si vous le souhaitez, les architectures suivantes :

- Progressive Web Applications
- Hybrid Applications : Cordova, Electron, Ionic‚Ä¶
- Microservices
- JAMStack [[6.]](/references/#r6)

Faites-nous savoir SVP si une architecture particuli√®re vous int√©resse et n'est pas reprise ci-dessus ; )


# <InternalPageTitle> Caract√©ristiques et workflow associ√©s √† une SPA </InternalPageTitle>

Une SPA (Single Page Application) offre de belles caract√©ristiques :

- **Pas de rechargement de page pendant l'utilisation** : en effet, on t√©l√©charge une seule fois l'ensemble du frontend (et donc de toutes les pages) ;
- **La r√©√©criture dynamique du contenu de la page** : lorsque l'on navigue d'une page √† une autre, on change que les parties de l'IHM qui doivent √™tre mises √† jour.
- **Pas d'interruption de l'exp√©rience de l'utilisateur** : lorsque l'utilisateur, via ses actions, am√®ne par exemple √† un appel √† une API, l'IHM reste disponible. Le browser peut r√©aliser des actions
  de mani√®re asynchrone (ou autrement dit, en parall√®le) et ne bloque pas l'exp√©rience utilisateur lors de long chargements (√† l'exception bien s√ªr du tout premier acc√®s √† l'application n√©cessitant le chargement complet du frontend).

Voici un exemple de workflow associ√© √† la SPA qui g√©rera le site de la pizzeria (que nous d√©veloppons au sein des tutoriels de ce cours), afin d'afficher le menu au sein de l'IHM :

<ScrollableImage name="readPizzas.png" minWidth="523px" maxWidth="523px" />
<figcaption>Exemple de Workflow classique d'une SPA</figcaption>

Une fois la page **`index.html`** charg√©e par le browser, celui-ci va faire des appels multiples au serveur de fichiers statiques afin de t√©l√©charger tous les assets n√©cessaires √† l'IHM.

Une fois l'IHM charg√©e, le browser lance en parall√®le un appel √† la RESTful API pour lire toutes les pizzas, tout en √©tant √† l'√©coute d'√©v√©nements qui pourrait se passer au niveau de l'IHM (clic, passage de souris sur un √©l√©ment...).

# <InternalPageTitle> Architectures associ√©es √† une SPA </InternalPageTitle>

## SPA : frontend ind√©pendant du backend
 
Il existe diff√©rentes architectures associ√©es √† une SPA.

Dans le cadre de ce cours, nous avons choisi d'avoir une IHM qui soit enti√®rement ind√©pendante de la RESTful API :

<ScrollableImage
  name="independentFrontBackSPA.png"
  minWidth="914px"
  maxWidth="914px"
/>
<figcaption> Frontend ind√©pendant de l'API </figcaption>

Lors du d√©veloppement, nous utiliserons donc le boilerplate du cours pour impl√©menter cette architecture. Webpack sera utilis√© comme serveur de fichiers statiques lors du d√©veloppement. Notons qu'il est possible d'utiliser d'autres serveurs lors du d√©veloppement, comme **Live Server** de VS Code, ou un package npm comme **serve**.  
En production, lorsque nous mettrons l'IHM sur le web, nous devrons nous tourner vers un autre serveur de fichiers statiques.

Voici l'architecture de la RESTfull API telle que d√©velopp√©e dans les modules pr√©c√©dents :

<ScrollableImage name="architecture.png" minWidth="859px" maxWidth="859px" />
<figcaption>RESTful API ind√©pendante du frontend</figcaption>

Nous voyons que ces architectures (frontend & backend) am√®nent √† deux projets bien distincts, un projet pour le frontend, et un autre pour le backend.

## SPA : architecture monolithique frontend/backend

Pour votre information, il est aussi possible d'avoir une architecture monolithique pour une SPA.  
Dans ce sc√©nario, la RESTful API s'occupe tant de fournir l'IHM via un serveur de fichiers statiques que d'offrir les op√©rations sur les ressources via un serveur dynamique.

Voici un exemple d'architecture monolithique possible √† l'aide de Node.js :

<ScrollableImage name="monolithicSPA.png" minWidth="758px" maxWidth="758px" />
<figcaption>SPA monolithique sous Express : chargement du frontend</figcaption>

Une fois le frontend charg√©, le browser pourra faire appel aux API et c'est le ou les router(s) de l'API qui prendront en compte les appels.

Nous n'appliquerons pas cette architecture dans le cadre de ce cours. N√©anmoins, vous aurez toutes les connaissances pour l'appliquer si vous le souhaitez.

## SPA : architectures en r√©sum√©

Voici en r√©sum√© les caract√©ristiques des deux architectures pr√©sent√©es ci-dessus :

- SPA dont le frontend est ind√©pendant du backend :
  - Frontend avec un serveur de fichiers statiques pour offrir l'IHM.
  - 2 serveurs : 1 serveur pour offrir le frontend, 1 serveur pour offrir le backend.
  - Ports diff√©rents pour le frontend & le backend.
- SPA monolithique :
  - RESTful API avec un serveur de fichiers statiques pour offrir l'IHM.
  - M√™me serveur pour offrir le frontend & le backend.
  - M√™me port pour le frontend & le backend.

Pour information, les ports permettent √† un m√™me appareil de communiquer sur un r√©seau en offrant plusieurs services. Chaque service, ou application, communique sur un et un seul port.

# <InternalPageTitle> Communications au sein d'une SPA </InternalPageTitle>

## Introduction aux protocoles de communications d'une SPA

Quelles protocoles & technique principale allons-nous utiliser pour communiquer au sein d'une SPA ?   
Il en existe plusieurs. Dans le cadre de ce cours, nous allons simplement voir la technique principale, **AJAX** (ou **A**synchronous **Ja**vaScript and **X**ML).

**AJAX** est une combinaison de technologies (HTML/CSS, DOM, JSON ou XML, XMLHttpRequest, JS) pour r√©aliser une application web asynchrone.  
C'est-√†-dire que le frontend reste disponible aux actions des utilisateurs m√™me lorsqu'il fait des requ√™tes HTTP asynchrone √† des API.
Le transport de donn√©es entre le frontend et l'API se faisait autrefois via **XML**. Actuellement, il se fait via **JSON**.

Notons que dans le cadre d'architectures MPA "old school" (non vues dans le cadre de ce cours), g√©n√©ralement, l'appel aux API ne se fait pas par le frontend, mais par le backend. Pendant toute la dur√©e de l'appel du frontend au backend, celui-ci reste en attente car la demande faite au backend est synchrone. Par exemple, lorsqu'un formulaire est envoy√© au serveur, l'action du formulaire est de demander une page au serveur (via la propri√©t√© "action" du formulaire HTML) ; jusqu'√† la r√©ponse du backend, aucune action d'un utilisateur ne sera possible au niveau de l'IHM.

Il existe d'autres moyens de communiquer entre applications web. Par exemple, les **websockets** sont une technologie de communication temps-r√©el client / serveur et bidirectionnelle.  
A la fin de ce cours, vous devriez √™tre apte √† d√©couvrir cette technologie par vous m√™me si vous le souhaitiez.

Avec **AJAX**, c'est le client qui doit initier la communication. Ca n'est pas le cas pour les **websockets**, le serveur peut le faire. Ainsi, avec **AJAX**, le client doit cr√©er une connexion HTTP √† chaque requ√™te.

## Librairies li√©es aux requ√™tes HTTP

Voici une liste de librairies bien connues pouvant parfois √™tre utilis√©e tant au niveau d'un browser (frontend) que via Node.js (backend) :

<ScrollableImage name="ajax.png" minWidth="569px" maxWidth="569px" />
<figcaption>Comparaison de librairies AJAX/HTTP [R.60]</figcaption>

Anciennement, il y a environ 20 ans, c'est la librairie **`XMLHttpRequest`** qui √©tait utilis√©e.  
Puis la librairie **`ajax`** avait pris l'ascendant via la m√©thode **`$.ajax()`**.

Le standard actuel pour le Vanilla JS, au niveau des browser, c'est la **`Fetch API`**. Dans ce cours, Nous allons utiliser cette API offerte par tous les browsers.

Notez que si vous souhaitez un jour utiliser une librairie pour vos requ√™tes HTTP, probablement que la plus utilis√©e actuellement c'est **`axios`**.

# <InternalPageTitle> Requ√™tes asynchrones & les promesses </InternalPageTitle>

La m√©thode **`fetch`** permet de faire des requ√™tes HTTP d'un browser vers des API.

Cette m√©thode est asynchrone, c'est-√†-dire quelle n'est pas bloquante, elle renvoie des promesses de r√©sultats via des objets **`Promise`**. Nous allons de mani√®re intuitive d√©couvrir la programmation asynchrone. Nous pourrons voir plus en d√©tails par la suite ce type de programmation √† l'aide de **promises** (les promesses).

Si un jour vous avez besoin de plus de documentation sur la m√©thode **`fetch`**, n'h√©sitez pas √† consulter la [documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) [[R.61]](/references/#r61).

Pour la pizzeria, l'IHM que nous avons d√©velopp√©e [dans la partie sur le routage des √©crans](../routing/) s'est termin√©e avec ce code :
[routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/routing-hmi) (**`/tutorials/pizzeria/hmi/routing`** au sein de votre repo).  
Pour ce nouveau tutoriel, au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/hmi/routing`** (ou [routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/routing-hmi)).

Cette SPA √©tait enti√®rement frontend, le **`MENU`** √©tant hardcod√© dans la **`HomePage`**.   
Nous souhaitons changer √ßa : afin de r√©cup√©rer une liste de pizzas, l'IHM doit faire une requ√™te **`fetch`** √† notre RESTful API d√©velopp√©e dans la partie [Refactoring √† l'aide d'un "fat model"](../../part1/refactoring/) :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Nous n'allons donc plus utiliser REST Client mais une fonction offerte par le browser pour faire l'√©quivalent de cette requ√™te :

```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Veuillez d√©marrer la RESTful API de la pizzeria (**`/tutorials/pizzeria/api/fat-model`** au sein de votre repo). En cas de souci, vous pouvez utiliser ce code-ci :
[fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Nous allons maintenant continuer le d√©veloppement de l'IHM (**`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`**). Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **`/web2/tutorials/pizzeria/hmi/basic-fetch-no-proxy`**.

Veuillez mettre √† jour le fichier **`src/Components/Pages/HomePage.js`** en supprimant l'array **`MENU`** et en rempla√ßant la ligne **`renderMenuFromString(pizzas);`** par cette requ√™te **`fetch`** pour lire toutes les pizzas :

```js numbered highlighting="4-14"
const HomePage = () => {
  clearPage();

  fetch('http://localhost:3000/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });

  attachOnMouseEventsToGoGreen();

  renderDrinksFromNodes(DRINKS);
};
```

Veuillez ex√©cuter le frontend.  
Ca ne fonctionne pas, nous obtenons ces erreurs dans la console du browser :

<ScrollableImage name="errors.png" minWidth="589px" maxWidth="589px" />

La premi√®re erreur est tr√®s int√©ressante pour comprendre la nature asynchrone de la fonction
**`fetch`**.

Par d√©faut, la fonction **`fetch`** fait une requ√™te de type **`GET`**.  
Ici on a donc demand√© √† la RESTful API, qui tourne sur le port **`8080`** de notre machine locale, la lecture de toutes les ressources de type "pizzas" :

```js
  fetch('http://localhost:3000/pizzas')
};
```

Comme la fonction **`fetch`** est asynchrone, le programme principal ne se bloque pas et n'attend
donc pas les r√©sultats. Directement apr√®s le d√©but du **`fetch`**, on passe √† la ligne 16 du morceau de code pr√©c√©dent : **`attachOnMouseEventsToGoGreen(pizzas);`**.  
Dans cette fonction, voici ce qui est fait :

```js numbered highlighting="2-3"
function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}
```

On essaie d'acc√©der √† la table HTML qui doit √™tre cr√©√©e par la m√©thode **`renderMenuFromString()`** qui n'a pas encore √©t√© appel√©e...  
üí≠ Mais pourquoi la table n'a pas √©t√© cr√©√©e alors que le morceau de code **`attachOnMouseEventsToGoGreen(pizzas);`** se trouve plus haut ?  
H√© bien c'est √ßa la programmation asynchrone, ce n'est qu'une fois le programme principal ex√©cut√© que les t√¢ches asynchrones, de priorit√© plus basses, pourront s'ex√©cuter.

Comment r√©ecrire ce code pour cha√Æner l'appel de **`attachOnMouseEventsToGoGreen(pizzas)`**
au succ√®s de l'op√©ration **`fetch`** ?

La m√©thode **`fetch`** renvoie une **`Promise`**, qui est un objet repr√©sentant un √©tat interm√©diaire d'une op√©ration. Le code des callbacks s'ex√©cute quand la t√¢che asynchrone est finie avec succ√®s ou si la t√¢che √©choue.

Les √©tats d'une promesse sont les suivants :

- **pending** : √©tat initial,
- **fulfilled** : l'op√©ration asynchrone a √©t√© termin√©e avec succ√®s ; par exemple la requ√™te
  **`fetch()`** a obtenu un flux de donn√©es avec la RESTful API,
- **rejected** : l'op√©ration asynchrone a √©chou√©e ; par exemple la requ√™te **`fetch`** est mal construite.

Pour r√©cup√©rer le r√©sultat d'une m√©thode asynchrone, on va faire appel :

- **`.then( callback )`** : ce morceau de code permet de cha√Æner des traitements asynchrones. Par exemple, √† la fin du premier traitement asynchrone associ√© au **`fetch()`**, on appelle

```js numbered highlighting="2-5"
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```

La **callback** sera appel√©e et recevra comme param√®tre un objet de type **`Response`** : cet objet ne contient pas encore le contenu du body de la r√©ponse. En fait, **`Response.body`** est un flux de donn√©es (un stream), il faudra donc faire appel √† un traitement asynchrone pour obtenir le contenu du body sous forme d'un objet JS.  
C'est ce qui est fait en renvoyant **`return response.json();`** : la fonction **`json()`** renvoie une promesse, c'est √† dire qu'une fois le traitement termin√©, nous pourrons cha√Æner celui-ci via un autre **`.then()`**.
C'est ainsi que nous cha√Ænons, une fois le **`body`** disponible, l'appel d'une deuxi√®me **callback** qui s'occupe de faire un render du menu de la pizzeria. Cette deuxi√®me **callback** recevra en param√®tre le body de la r√©ponse sous forme d'un objet JS :

```js numbered highlighting="6-8"
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```

Si nous souhaitons cha√Æner l'ajout des √©couteurs d'√©v√©nements sur la table HTML, puis l'affichage des boissons, c'est donc dans cette **callback** qu'il faut le faire. Veuillez mettre √† jour le code afin d'√©liminer la premi√®re erreur qu'il y avait dans la console :

```js numbered highlighting="9-13"
const HomePage = () => {
  clearPage();

  fetch('http://localhost:3000/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
      attachOnMouseEventsToGoGreen();
      renderDrinksFromNodes(DRINKS);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });
};
```

La console de votre browser devrait afficher une erreur en moins.

- **`.catch( callback )`** : ce morceau de code permet d'ex√©cuter une **callback** lorsque la t√¢che asynchrone associ√©e √† la promesse √©choue. Dans le code, on voit que l'on affiche juste un message dans la console :

```js numbered highlighting="11-13"
fetch('http://localhost:3000/pizzas')
  .then((response) => {
    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
    return response.json();
  })
  .then((pizzas) => {
    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  })
  .catch((err) => {
    console.error('HomePage::error: ', err);
  });
};
```

- **`.finally( callback )`** : si l'on souhaite ex√©cuter une callback quelque soit le r√©sultat de la promesse, en cas de succ√®s ou d'√©chec.

‚ö° Pour le cha√Ænage des traitements via plusieurs callback appel√©es au sein de **`.then()`**, cela n'est possible que s'il y a un **`return`** dans les callback.

En effet, si une callback dans la gestion de promesses retourne :

- **Une valeur** : la promesse retourn√©e par **`then`** est r√©solue avec la valeur.
- **Pas de valeur** : la promesse retourn√©e par **`then`** est r√©solue avec **`undefined`**.
- **Une autre promesse "pending"**: la promesse retourn√©e par **`then`** est r√©solue/rejet√©e √† la suite de la r√©solution/rejet de la promesse retourn√©e par la **callback**.

Pour info, autrefois, pour la programmation asynchrone en JS, nous utilisions simplement les callbacks, des fonctions que l'on passait en argument d'autres fonctions. Le code pouvait facilement devenir illisible et donc difficilement maintenable.

üí≠ OK, nous avons appris les fondements de la programmation asynchrone moderne en JS...  
Mais √ßa ne fonctionne pas, nous n'avons toujours l'erreur associ√©e aux "CORS policy".  
Cette erreur, c'est un mur classique contre lequel tous les programmeurs web se cognent au moins une fois dans leur carri√®re üòµ.

Nous allons apprendre √† r√©soudre cette erreur dans la partie qui suit, car celle-ci d√©pend de la fa√ßon dont l'API a √©t√© configur√©e. Si vous souhaitez voir l'application fonctionner, vous pouvez :
- Stopper la RESTful API ;
- T√©l√©charger, et d√©sarchiver cette API : <LinkFile name="api-json-server.zip" target="_blank" download> RESTful API offerte gr√¢ce √† json-server </LinkFile>
- Lancer l'API t√©l√©charg√©e : 
  - Ouvrir un terminal dans son r√©pertoire.
  - Installation des packages : **`npm i`**
  - Ex√©cution de l'API : **`npm start`**
- Faire un refresh au niveau de votre browser. Le menu des pizzas devrait s'afficher üéâ.

A ce stade-ci, faites un **commit** de votre repo (**`web2`**) avec comme message : **`basic-fetch-no-proxy-hmi tutorial`**.

En cas de souci, vous pouvez acc√©der au code de cette √©tape du tutoriel ici : [basic-fetch-no-proxy-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch-no-proxy).



# <InternalPageTitle> Exercice 2.15 : Consommation de blagues online </InternalPageTitle>

Nous souhaitons consommer une API qui nous permette d'afficher des blagues.  
Nous avons trouv√© une restful API qui permet tr√®s facilement de g√©n√©rer de mani√®re al√©atoire des **`jokes`** : [JokeAPI](https://v2.jokeapi.dev/).

Cette API est tr√®s simple d'utilisation. D'ailleurs, la page du site [JokeAPI](https://v2.jokeapi.dev/) vous donne un exemple fonctionnel de comment r√©cup√©rer des blagues simples dans l'onglet **`Try it out here`**. Pour cela, d√©s√©lectionnez **`twopart`** et vous obtenez l'URL pour faire vos requ√™tes en dessous du formulaire.

Dans la **`HomePage`** d'une nouvelle application frontend, veuillez afficher une **`joke`** apr√®s l'avoir r√©cup√©r√©e de **`JokeAPI`**, en donnant ces 2 informations :
- la cat√©gorie associ√©e √† la **`joke`** ;
- le texte associ√© √† la **`joke`**.

Veuillez cr√©er un nouveau projet dans votre repository local et votre web repository (normalement appel√© **`web2`**) nomm√© **`/exercises/2.15`** sur base du [boilerplate du cours avec routeur](https://github.com/e-vinci/js-router-boilerplate.git).

‚ö° Si vous avez fait un clone du boilerplate, attention au Git dans le Git, n'oubliez pas de supprimer le dossier **`.git`** pr√©sent dans votre nouveau projet.

Quand votre application est finalis√©e, veuillez faire un **`commit`** de votre code avec comme message : **`2.15 : view online jokes`**.

# <InternalPageTitle> Exercice 2.16 : Consommation de questions localement </InternalPageTitle>

## Affichage des questions et r√©ponses

Votre nouvelle application va proposer des jeux de devinettes √©ducatifs pour aider les enfants √† am√©liorer leur logique, leur raisonnement et leurs comp√©tences de r√©solution de probl√®mes.

Au chargement de l'application, vous devez al√©atoirement afficher trois devinettes sur base de la liste de toutes les questions qui vous est offerte par une RESTful API locale.

La RESTful API vous est fournie ici : <LinkFile name="api-json-server.zip" target="_blank" download> RESTful API offerte gr√¢ce √† json-server </LinkFile>. Une fois dans le dossier, √† l'aide d'un terminal, vous pouvez lancer cette API en utilisant les commandes suivantes : 
- **`npm i`**
- **`npm start`**

La liste de question est disponible via cette URL : **http://localhost:3000/questions**.


Vous devez aussi ajouter un bouton √† la fin du questionnaire qui permettra, plus tard, de calculer le score. 
Voici comment vous devez afficher chaque devinette :
-	La question doit √™tre facilement reconnaissable par rapport aux r√©ponses.
-	Chaque r√©ponse doit √™tre associ√©e √† un "radio button".
-	Il doit √™tre impossible de "checker" plus qu'un "radio button" par devinette (car il n'y a jamais qu'une seule r√©ponse possible !).

Voici un exemple de ce √† quoi pourrait ressembler votre application web :
<ScrollableImage name="ex2-16-questions.png" minWidth="370px" maxWidth="370px" />

Quand l'affichage des questions & r√©ponses est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`2.16.1 : view local questions`**.

## üç¨ Calcul et affichage des scores (suite optionnelle de l'exercice)

Lorsque l'utilisateur clique sur le bouton pour calculer le score, vous devez afficher uniquement le score de l'utilisateur et un bouton permettant de recommencer un jeu de devinettes. Les questions ne sont donc plus visibles. Pour calculer le score :
-	Une r√©ponse juste am√®ne 1 point.  
NB : la r√©ponse juste √† une question doit √™tre d√©termin√©e gr√¢ce √† **`isCorrect`** qui est une propri√©t√© des ressources renvoy√©es par l'API ; si **`isCorrect`** est vrai, c'est que c'est la bonne r√©ponse.
-	Une r√©ponse fausse am√®ne 0 points. Si aucune r√©ponse est s√©lectionn√©e pour une question, cela reviendra √† une r√©ponse fausse.
-	Le score sera donn√© sur 3 points.

Voici un exemple de ce √† quoi pourrait ressembler l'√©cran pour le score :
<ScrollableImage name="ex2-16-score.png" minWidth="268px" maxWidth="268px" />

Quand votre application est finalis√©e, veuillez faire un **`commit`** de votre code avec comme message : **`2.16.2 : calculate score`**.