---
title: 'Language JS'
description: 'Introduction au langage JavaScript, apprentissage de la syntaxe'
---

# c) Introduction au langage JS

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part0" > Partie 0 </PathViewerItem>
    <PathViewerItem selected> c) JS </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Les instructions </InternalPageMenuItem>
  <InternalPageMenuItem> Les commentaires </InternalPageMenuItem>
  <InternalPageMenuItem> Les variables et constantes </InternalPageMenuItem>
  <InternalPageMenuItem> Les opÃ©rateurs </InternalPageMenuItem>
  <InternalPageMenuItem> Les conditions </InternalPageMenuItem>
  <InternalPageMenuItem> Les fonctions </InternalPageMenuItem>
  <InternalPageMenuItem> Les boucles </InternalPageMenuItem>
  <InternalPageMenuItem> Les tableaux </InternalPageMenuItem>
  <InternalPageMenuItem> Les template literals </InternalPageMenuItem>
  <InternalPageMenuItem> Les objets </InternalPageMenuItem>
  <InternalPageMenuItem> Les exceptions </InternalPageMenuItem>
  <InternalPageMenuItem> Le destructuring assignment </InternalPageMenuItem>
</InternalPageMenu>

Le JS s'Ã©crit tant dans un browser que dans un environnement serveur.

Quand on Ã©crit du JS au niveau client, on Ã©crira du JS conforme au standard **`ECMAScript`**.

Quand on Ã©crit du JS au niveau serveur, on Ã©crira du Node.js, du JS conforme au standard **`CommonJS`**.

Il existe des diffÃ©rences lorsqu'on Ã©crit du JS pour un browser ou lorsqu'on Ã©crit du JS pour une application serveur. NÃ©anmoins, il existe une syntaxe commune que nous allons voir dans ce chapitre.

# <InternalPageTitle> Les instructions </InternalPageTitle>

ğŸ‘ MÃªme si ce n'est pas obligatoire, on recommande de sÃ©parer chaque instruction par un "Â **`;`** ".

Cela permet d'augmenter la lisibilitÃ© du code.

```js
let x = 1;
console.log('xÂ =Â ', x);
```

**`console.log()`** : c'est une mÃ©thode qui permet d'afficher un message dans la console du browser ou de l'environnement Node.js. En Java, c'est l'Ã©quivalent de **`System.out.println()`** en Java.

# <InternalPageTitle> Les commentaires </InternalPageTitle>

On ajoute des commentaires dans son code via :

- " **`//`** " : une seule ligne commentÃ©e.
- " **`/*`** " et "Â **`*/`** " : un bloc de lignes commentÃ©.
- " **`/**`** " et "Â **`*/`** " : un bloc de lignes commentÃ© pour gÃ©nÃ©rer la `JSDoc` d'une fonction.

```js
/**
 *Â JSDocÂ asÂ comments
 *Â @paramÂ {message}Â messageÂ toÂ beÂ displayed in console
 */
function raiseAlert(message) {
  //Â SingleÂ lineÂ comment
  console.log(message); /*Â RegularÂ comment
Â Â Â Â onÂ multipleÂ lines
Â Â Â Â */
  console.log('AnÂ alertÂ hasÂ beenÂ raised.');
}
```
# <InternalPageTitle> Les variables et constantes </InternalPageTitle>

## Variable key sensitive

En JS, on ne dÃ©clare pas le type de variable, c'est un langage dynamiquement typÃ©, c'est-Ã -dire que le type d'une variable est dÃ©terminÃ© Ã  l'exÃ©cution.

Les variables sont sensibles Ã  la casse (ou "case sensitive") :

```js
//Â twoÂ differentÂ variables
let monBrowser;
let monbrowser;
```

## Variables locales

Pour dÃ©finir une variable locale dont sa portÃ©e est associÃ©e Ã  un bloc,
on utilise : **`let`**.

```js
if (true) {
  let blockScope = 'Hello';
  console.log(blockScope); //Â Hello
}
console.log(blockScope); //Â UncaughtÂ ReferenceError:Â blockScopeÂ isÂ not defined
```

Une variable **`let`** [[7.]](/references/#r7) :
- n'est pas accessible en dehors du bloc oÃ¹ elle est dÃ©finie ;
- est processÃ©e Ã  l'exÃ©cution seulement ;
- ne peut pas Ãªtre redÃ©clarÃ©e dans le mÃªme bloc.

## constantes locales

Pour dÃ©finir une constante dont sa portÃ©e est associÃ©e Ã  un bloc,
on utilise : **`const`** [[8.]](/references/#r8).

```js
if (true) {
  const constVar = 'Hello';
  console.log(constVar); //Â Hello
  const SITE_URL = 'http://MyCMS.org';
  console.log(SITE_URL); //Â http://MyCMS.org
  constVar = 'Hi'; //Â UncaughtÂ TypeError:Â AssignmentÂ toÂ constant variable.
  console.log(constVar);
}
```

## Variables globales

Pour dÃ©finir une variable globale si elle est dÃ©clarÃ©e en dehors d'une fonction, on utilise : **`var`**.

```js
if (true) {
  var globalVar = 'Hello';
  console.log(globalVar); //Â Hello
}
console.log(globalVar); //Â Hello
```

Une variable **`var`** est:
- processÃ©e avant l'execution du code ("hoisting") ;
- accessible au travers de tout le programme ;
- redÃ©clarable dans nâ€™importe quel bloc.

## Variables dont la portÃ©e est associÃ©e Ã  une fonction

Pour dÃ©finir une variable ou constante dont la portÃ©e est associÃ©e Ã  une fonction, on peut utiliser : **`let`**, **`const`** ou **`var`**.

```js
function checkScopeVarInFunction() {
  var varInFunction = 'Hello';
  console.log(varInFunction); //Â Hello
}
checkScopeVarInFunction();
console.log(varInFunction); //Â UncaughtÂ ReferenceError:Â varInFunctionÂ isÂ not defined
```

ğŸ‘ Nous vous recommandons d'utiliser **`let`** ou **`const`** lorsque vous dÃ©clarer une variable ou constante au sein d'une fonction.

<br />

## Assignation d'une valeur Ã  une variable non dÃ©clarÃ©e

L'assignation d'une valeur Ã  une variable non dÃ©clarÃ©e crÃ©e implicitement une variable globale.

```js
function checkScopeVarInFunction() {
  varInFunction = 'Hello';
  console.log(varInFunction); //Â Hello
}
checkScopeVarInFunction();
console.log(varInFunction); //Â Hello
```

ğŸ‘ Nous vous recommandons de ne jamais utiliser de variables non dÃ©clarÃ©es.

<br />

## Les dangers des variables globales

âš¡ L'utilisation de variables globales peut s'avÃ©rer dangereux.

On crÃ©e une variable globale soit via **`var`**, soit en initialisant une variable non dÃ©clarÃ©e.

```js
var index = 1;
for (index; index <= 3; index++) {
  console.log(index); //Â 1Â 2 3
}
print();
function print() {
  for (index; index <= 5; index++) {
    console.log('PrintÂ ' + index); //Â PrintÂ 4Â PrintÂ 5
  }
}
```

Dans cet exemple de code, on s'attendrait Ã  ce que la deuxiÃ¨me boucle affiche :
**`Print 1 Print 2 Print 3 Print 4 Print 5`**.

## Recommandations concernant la portÃ©e de vos variables

âš¡ L'utilisation de variables globales peut s'avÃ©rer dangereux quand on souhaiterait que la durÃ©e de vie de celle-ci corresponde Ã  un bloc de code bien prÃ©cis.

ğŸ‘ Nous vous recommandons de dÃ©finir des variables dont la portÃ©e est correctement exprimÃ©e par le mot-clÃ© utilisÃ© lors de la dÃ©finition :

- utilisez **`let`** ou **`const`** pour des variables ou constantes disponibles au sein d'un bloc de code uniquement;
- utilisez **`var`** (ou **`const`**) que si une variable (ou constante) doit Ãªtre disponible au sein de tous les blocs d'un script. NÃ©anmoins, mÃªme dans ce cas-ci, on prÃ©fÃ©rera utiliser une variable via **`let`**.

## Types de variables

Voici les types principaux de variables qui seront dÃ©terminÃ©s lors de l'initialisation d'une variable :

- **`Number`** (Nombre)Â : un seul type pour les entiers, rÃ©els, doublesâ€¦
- **`String`** (ChaÃ®ne)Â : comprise entre guillemets simples, doubles ou entre **\`** et **\`**.
- **`Bool`** (BoolÃ©en).
- **`Array`** (Tableau).
- **`Object`** (Objet).

Afin de renvoyer sous forme d'une string le type d'une expression, on utilise l'opÃ©rateur **`typeof`**.

```js
console.log(typeof 12); //Â number
console.log(typeof 'IÂ loveÂ JS'); //Â string
console.log(typeof true); //Â boolean
console.log(typeof undeclaredVariable); //Â undefined
```

# <InternalPageTitle> Les opÃ©rateurs </InternalPageTitle>
## OpÃ©rateurs d'Ã©galitÃ© ou de non Ã©galitÃ©

Pour une comparaison stricte, sans conversion de type, on utilise **`===`** ou **`!==`**.

Pour une comparaison avec conversion de type, on utilise **`==`** ou **`!=`**.

```js
1 === 1; //Â true
'1' === 1; //Â false
1 == 1; //Â true
'1' == 1; //Â true
0 == false; //Â true
0 == null; //Â false
var object1 = { key: 'value' },
  object2 = { key: 'value' };
object1 == object2; //false
```

ğŸ‘ Nous recommandons en gÃ©nÃ©ral d'utiliser l'Ã©galitÃ© stricte sauf si vous souhaitez convertir le type des variables comparÃ©es.

## Optional chaining operator : ?.

L'opÃ©rateur **`?.`** permet de lire la valeur d'une propriÃ©tÃ© d'un objet sans devoir contrÃ´ler si la rÃ©fÃ©rence de l'objet est valide.

Il agit comme l'opÃ©rateur **`.`** sauf qu'au lieu de causer une erreur si une rÃ©fÃ©rence (d'une variable) est "nullish", c'est-Ã -dire **`null`** ou **`undefined`**, l'expression est court-circuitÃ©e et renvoie **`undefined`**.

Sans test de condition, voici un morceau de code qui soulÃ¨ve une exception :

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

const dogName = adventurer.dog.name; //Error: Cannot read properties of undefined (reading 'name')
console.log(dogName);
```

En effet, la rÃ©fÃ©rence dog est **`undefined`**.  
Avant le rÃ©cent "optional chaining operateur", voici ce que nous aurions pu Ã©crire comme code avant d'initialiser **`dogName`** :

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

let dogName;

if (adventurer !== undefined && adventurer.dog !== undefined)
  // often simplified to : if(adventurer && adventurer.dog)
  dogName = adventurer.dog.name;

console.log(dogName); // undefined
```

Si la propriÃ©tÃ© d'un objet ne renvoyait jamais une valeur valide Ã©tant Ã  **false** ou **0**, alors on simplifiait souvent le check des valeurs nullish Ã  qqch du style :
**`if(adventurer && adventurer.dog)`**.

Maintenant, grÃ¢ce Ã  l'opÃ©rateur **`?.`**, nous pouvons Ã©crire du code trÃ¨s concis et ne plus Ã©crire de tests de conditions pour les valeurs de type "nullish" :

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

const dogName = adventurer?.dog?.name;

console.log(dogName); // undefined

console.log(adventurer?.someNonExistentMethod?.()); // undefined

console.log(adventurer?.kids?.[0]?.name); // undefined

const kids = [{ name: 'John' }];
let kids2;

console.log(kids?.[0]?.name); // "John"
console.log(kids2?.[0]?.name); // undefined
```

## Nullish coalescing operator : ??

Le "nullish coalescing operator" permet de renvoyer ce qui se trouve Ã  droite de l'opÃ©rateur quand ce qui se trouve Ã  gauche est "nullish" (**`null`** ou **`undefined`**).

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

const dogName = adventurer?.dog?.name ?? 'No dog';
console.log(dogName); // "No dog"

const catName = adventurer?.cat?.name ?? 'No cat';
console.log(catName); // "Dinah"
```

## Spread operator : ...

### Spread operator au niveau d'un objet

Voici un exemple d'utilisation de **`spread operator`** :

```js
const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'GruyÃ¨re, SÃ©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'GruyÃ¨re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];
const updatedPizza = {...MENU[foundIndex], ...req.body};
```

Le **`spread operator`** est trÃ¨s utile en JS, ce sont les **`...`**.  
Ici, nous crÃ©ons un nouvel objet en intÃ©grant deux objets : **`MENU[foundIndex]`** et **`req.body`**.  
Le **`spread operator`** permet de faire une "shallow copy", ou copie peu profonde, d'un Ã©lÃ©ment de l'array **`MENU`**, Ã  l'aide de **`...MENU[foundIndex]`**.  
Cela reprend toutes les propriÃ©tÃ©s de l'objet identifiÃ© par **`foundIndex`**.  
Ensuite, nous remplaÃ§ons les propriÃ©tÃ©s existantes de cette objet par les propriÃ©tÃ©s donnÃ©es dans **`req.body`** Ã  l'aide de **`...req.body`**. Bien sÃ»r, si l'objet **`...req.body`** contient des nouvelles propriÃ©tÃ©s, celles-ci seront ajoutÃ©e Ã  **`updatedPizza`**. 

### Spread operator au niveau d'un array
Voici un exemple de **`spread operator`** (voir les 3 petits points) :

```js
orderedMenu = [...MENU].sort((a, b) => a.title.localeCompare(b.title));
```

Ici nous souhaitons faire un tri d'un **`MENU`** (qui est un array) sur base d'une copie de celui-ci.  
ğŸ’­ Mais pourquoi le faire sur une copie ?  
Si nous autorisons Ã  trier l'array associÃ© au **`MENU`**, lorsque nous tenterons d'ajouter un nouvel Ã©lÃ©ment, le dernier Ã©lÃ©ment de l'array ne contiendra plus le dernier id (ou l'id le plus haut), car la fonction **`sort`** modifie l'array sur lequel la mÃ©thode est appelÃ©e !  
Nous souhaitons donc travailler sur une copie de cet array : **`[...MENU]`** crÃ©e un nouveau tableau contenant tous les Ã©lÃ©ments du **`MENU`**.

### Spread operator en rÃ©sumÃ©
Le **`spread operator`** est trÃ¨s puissant, il permet d'Ã©crire du code concis et lisible.  
Il est utilisÃ© dans les objets, les arrays, ainsi que comme paramÃ¨tre de fonction.  

N'hÃ©sitez pas Ã  consulter la [documentation de MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) [[R.57]](/references/#r57) pour en savoir plus.

## Les autres opÃ©rateurs

Nous ne verrons pas tous les opÃ©rateurs logiques dans ce cours, ils sont sensÃ©s Ãªtre connus.

Par exemple, les opÃ©rateurs logiques sont les habituels : **`&&`**, **`||`**, **`!`**

NÃ©anmoins, vous avez tous les opÃ©rateurs disponibles dans [la documentation MDN ici](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators) [[R.9]](/references/#r9).

# <InternalPageTitle> Les conditions </InternalPageTitle>

Comme dans la majoritÃ© des langages, les instructions conditionnelles sont construites Ã  l'aide de **`if`** ... **`else`**.

Si vous souhaitez revoir les instructions conditionnelles, vous pouvez le faire dans la [documentation MDN ici](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#conditional_statements) [[R.10]](/references/#r10).

```js
let isAuthenticated = false;
if (isAuthenticated) {
  console.log('RenderÂ theÂ HomePage.');
  console.log('YouÂ areÂ authenticated.');
} else {
  console.log('RenderÂ theÂ LoginÂ Page.'); //Â RenderÂ theÂ LoginÂ Page.
  console.log('YouÂ areÂ notÂ authenticated.'); //Â YouÂ areÂ notÂ authenticated.
}
```

Voici un exemple de **`switch`** :

```js
let foo = 0;
switch (foo) {
  case -1:
    console.log('negativeÂ 1');
    break;
  case 0: //Â fooÂ isÂ 0Â soÂ criteriaÂ metÂ hereÂ soÂ thisÂ blockÂ willÂ run
    console.log(0);
  case 1: //Â noÂ breakÂ statementÂ inÂ 'caseÂ 0:'Â soÂ thisÂ caseÂ willÂ runÂ asÂ well
    console.log(1);
    break; //Â itÂ encountersÂ thisÂ breakÂ soÂ willÂ notÂ continueÂ intoÂ 'caseÂ 2:'
  case 2:
    console.log(2);
    break;
  default:
    console.log('default');
}
```

# <InternalPageTitle> Les fonctions </InternalPageTitle>

En JS, il existe plusieurs faÃ§on de dÃ©clarer des fonctions.

## Les fonctions personnalisÃ©es

Ce sont des fonctions qui portent un nom, dÃ©finies Ã  l'aide du mot-clÃ© **`function`**.

```js
function welcomeMessage(message) {
  return 'MessageÂ :Â ' + message;
}
let message = welcomeMessage('WelcomeÂ toÂ everyone!');
console.log(message); //Â MessageÂ :Â WelcomeÂ toÂ everyone!
```

## Les fonctions comme valeurs de variables

En JS, on peut assigner une fonction comme valeur de variable :

```js
function welcomeMessage(message) {
  return 'MessageÂ :Â ' + message;
}
let x = welcomeMessage;
message = x('Hi');
console.log(message); //Â MessageÂ :Â Hi
```

### Les fonctions anonymes

Ce sont des fonctions qui ne portent pas de nom.

```js
const welcome = function (message) {
  return 'MessageÂ :Â ' + message;
};
message = welcome('HelloÂ worldÂ ;Â )');
console.log(message); //Â MessageÂ :Â HelloÂ worldÂ ;Â )
```

Si une fonction n'est jamais rÃ©utilisÃ©e et est trÃ¨s courte, il est parfois pratique de ne pas lui donner de nom.

## Les fonctions "arrow"

Ce sont des fonctions qui ne portent pas de nom et qui s'Ã©crivent sous une forme encore plus courte que les fonctions anonymes.

```js
const welcome2 = (message) => {
  return 'MessageÂ :Â ' + message;
};
message = welcome2('HelloÂ world...');
console.log(message); //Â MessageÂ :Â HelloÂ world...
//Â OTHERÂ EXAMPLE
const higher = (n) => n + 1;
console.log(higher(1)); //Â 2
```

On peut ne pas mettre les parenthÃ¨ses si et seulement si la fonction ne possÃ¨de qu'un seul paramÃ¨tre.

On peut ne pas mettre les accolades si et seulement si le code est une expression, c'est-Ã -dire si la fonction renvoie quelque chose ; dans ce cas, on ne met pas de **`return`**.

## Les paramÃ¨tres de fonctions

Les paramÃ¨tres d'une fonction sont optionnels. Lors de l'appel d'une fonction, le valeur **`undefined`** est allouÃ©e aux paramÃ¨tres manquants.

Les paramÃ¨tres ont une portÃ©e locale au sein de la fonction.

Le passage des paramÃ¨tres se fait par valeur, sauf pour les objets oÃ¹ il se fait par rÃ©fÃ©rence.

Voici un exemple de passage d'un paramÃ¨tre par valeur (la variable utilisÃ©e dans la fonction est un clone du paramÃ¨tre qui a Ã©tÃ© passÃ© Ã  la fonction lors de l'appel) :

```js
let myMessage = 'Hello';
print(myMessage);
function print(myMessage) {
  console.log(myMessage); //Â Hello
  myMessage = 'GoodÂ bye';
}
console.log(myMessage); //Â Hello
```

Voici un exemple de passage d'un paramÃ¨tre, un objet, par rÃ©fÃ©rence (la variable utilisÃ©e dans la fonction n'est pas un clone du paramÃ¨tre qui a Ã©tÃ© passÃ© Ã  la fonction lors de l'appel, c'est l'objet lui-mÃªme) :

```js
let myMessage = { content: 'Hello' };
consolePrint(myMessage);
function consolePrint(myMessage) {
  console.log(myMessage.content); //Â Hello
  myMessage.content = 'GoodÂ bye';
}
console.log(myMessage.content); //Â GoodÂ bye
```

Les fonctions acceptent des paramÃ¨tres optionnels avec une valeur par dÃ©faut qui est allouÃ©e lorsque ces paramÃ¨tres sont omis lors de l'appel :

```js
let welcome3 = function (message = 'HIÂ DEARÂ HUMAN!') {
  return 'MessageÂ :Â ' + message;
};
message = welcome3();
console.log(message); //Â HIÂ DEARÂ HUMAN
```

## Autres caractÃ©ristiques des fonctions

Il existe encore d'autres caractÃ©ristiques pour les fonctions.

Par exemple, une fonction retourne une valeur Ã  l'aide de **`return`**.

Si vous souhaitez en savoir plus, vous pouvez lire [la documentation MDN ici](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) [[R.11]](/references/#r11).

# <InternalPageTitle> Les boucles </InternalPageTitle>

Les boucles permettent de rÃ©pÃ©ter certaines tÃ¢ches.

Si vous souhaitez en savoir plus sur l'utilisation de diffÃ©rents types de boucles en JS, vous pouvez le faire via la [documentation MDN ici](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Looping_code) [[R.12]](/references/#r12).

On utilise ces mots-clÃ©s pour dÃ©finir des boucles en JS :
**`for`**, **`for`**/**`in`**, **`for`**/**`of`**, **`while`**, **`do`**/**`while`**.

Nous verrons aussi plus tard qu'il existe des fonctions sur des **`Array`** permettant de boucler sur les Ã©lÃ©ments d'un tableau.

S'il y a un type de boucle Ã  retenir, c'est la boucle **`for`**, la plus classique, qui fonctionne dans tous les langages et avec la majoritÃ© des structures de donnÃ©es :

```js
for (let index = 0; index < 5; index++) {
  console.log(index); //Â 0Â 1Â 2Â 3Â 4
}
```

# <InternalPageTitle> Les tableaux </InternalPageTitle>
## Introduction

Les tableaux sont des variables ou constantes de type **`Array`**.  
Un array (ou tableau) est un ensemble ordonnÃ© de valeurs auxquelles ont fait rÃ©fÃ©rence avec un nom et un indice.

## CrÃ©ation de tableaux

```js
constÂ LIBRARIESÂ =Â ["Anime.js",Â "Three.js",Â "Phaser.io"];
constÂ emptyArrayÂ =Â [];
constÂ LIBRARIES_NOT_RECOMMENDEDÂ =Â newÂ Array("Anime.js", "Three.js", "Phaser.io");
constÂ emptyArrayNotRecommendedÂ =Â newÂ Array();
constÂ arrÂ =Â newÂ Array(10, 100)Â ;Â //Â WhatÂ isÂ theÂ resultÂ ?Â 
constÂ arr2Â =Â newÂ Array(10)Â ;Â //Â WhatÂ isÂ theÂ resultÂ ?Â 
}
```

âš¡ Dans l'exemple ci-dessus, **`arr`** est un tableau de deux Ã©lÃ©ments contenant les valeurs **`10`** et **`100`**. Or **`arr2`** est un tableau de **`10** Ã©lÃ©ments ne contenant aucune valeur...
C'est assez dÃ©routant et donc dÃ©conseillÃ© de crÃ©er un tableau Ã  l'aide du constructeur.

ğŸ‘ Il est recommandÃ© de crÃ©er un array Ã  l'aide de **`[]`**.

## Parcourir un tableau

On peut parcourir un tableau soit Ã  l'aide des boucles classiques (**`for`** & **`.length`**), soit Ã  l'aide de la mÃ©thode **`forEach()`**.

```js
for (let index = 0; index < LIBRARIES.length; index++) {
  console.log(LIBRARIES[index]); //Â Anime.jsÂ Three.jsÂ Phaser.io
}

LIBRARIES.forEach((item, index) => console.log('[' + index + ']:Â ' + item));
//Â [0]:Â Anime.jsÂ [1]:Â Three.jsÂ [2]:Â Phaser.io

LIBRARIES.forEach(function (item) {
  return console.log(item); //Â Anime.jsÂ Three.jsÂ Phaser.io
});
```

## Les tableaux multidimensionnels

Un tableau Ã  deux dimensions, en JS, est un tableau dont tous ses Ã©lÃ©ments sont des tableaux.

```js
constÂ numberOfRowsÂ =Â 2,
constÂ numberOfColumnsÂ =Â 2;
constÂ myTabÂ =Â [];
forÂ (letÂ xÂ =Â 0;Â xÂ <Â numberOfRows;Â x++)Â {
Â Â myTab.push([]); // cleaner than : myTab[x]Â =Â [];
Â Â forÂ (letÂ yÂ =Â 0;Â yÂ <Â numberOfColumns;Â y++)Â {
Â Â Â Â myTab[x].push("["Â +Â xÂ +Â "]["Â +Â yÂ +Â "]");Â 
    //Â myTab[x][y]Â =Â "["Â +Â xÂ +Â "]["Â +Â yÂ +Â "]";Â notÂ recommended
Â Â Â Â console.log(myTab[x][y]);
Â Â }
}
```

## Autres mÃ©thodes associÃ©es aux tableaux

Il existe de nombreuses mÃ©thodes intÃ©ressantes associÃ©es aux tableaux, comme : **`pop()`**, **`map()`**, **`indexOf()`**.

Si vous souhaitez approfondir ce sujet, vous pouvez consulter [la MDN documentation ici](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) [[R.13]](/references/#r13).

# <InternalPageTitle> Les template literals </InternalPageTitle>

On peut Ã©crire des String sur plusieurs lignes Ã  l'aide de **\` \`**.

Il est possible d'inclure des expressions, gÃ©nÃ©ralement les valeurs de variables, dans des String en utilisant **`${}`**.

```js
for (let i = 0; i < LIBRARIES.length; i++) {
  htmlText += `<liÂ class='list-group-item'>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ${LIBRARIES[i]}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </li>`;
}
```

# <InternalPageTitle> Les objets </InternalPageTitle>
## Introduction

En JS, tout est objet : les Strings, les tableaux, les API du browser, les objets personnalisÃ©s...

Cette partie ne donne que les bases de la gestion d'objets. Une autre partie du cours, appelÃ©e l'orientÃ© objet en JS, fournit plus de dÃ©tails.

## CrÃ©ation d'objets

### Introduction

Il existe plusieurs faÃ§ons de crÃ©er un objet en JS.

### CrÃ©ation d'un "object literal"

On peut crÃ©er un "object literal", qui est une liste de paires clÃ©/valeur.

La clÃ© sera le nom de la propriÃ©tÃ© d'un objet.

```js
let raphael = {
  firstname: 'Raphael',
  lastname: 'Baroni',
  sayHello: () => 'HiÂ everyoneÂ !',
};
```

### CrÃ©ation d'objets vide

On crÃ©e un objet vide via **{}**.

âš¡ Il n'est pas recommandÃ© de crÃ©er un objet en utilisant le constructeur d' **`Object`** via le mot clÃ© **`new`**.

```js
let sandra = {};
sandra.firstname = 'Sandra';
sandra.lastname = 'Parisi';
```

## AccÃ©der aux propriÃ©tÃ©s dâ€™un objet

### Introduction

Il existe deux faÃ§ons d'accÃ©der aux propriÃ©tÃ©s d'un objet.

### AccÃ¨s Ã  une propriÃ©tÃ© via un .

On accÃ¨de rÃ©guliÃ¨rement aux propriÃ©tÃ©s d'un objet via un **`.`** :

```js
console.log(raphael.firstname, 'Â :', raphael.sayHello()); //Â RaphaelÂ Â :Â HiÂ everyoneÂ !
```

### AccÃ¨s Ã  une propriÃ©tÃ© via un ["object_key"]

On utilisera la clÃ©, c'est-Ã -dire le nom de la propriÃ©tÃ© recherchÃ©e, sous forme de String, principalement dans les cas oÃ¹ l'on souhaite, lors de l'exÃ©cution, accÃ©der dynamiquement Ã  une propriÃ©tÃ© :

```js
console.log(sandra['firstname'], ',', sandra['lastname']);
//Â SandraÂ ,Â Parisi
```

# <InternalPageTitle> Les exceptions </InternalPageTitle>
## Lancer une expression

Les exceptions permettent de gÃ©rer des cas d'erreur se produisant lors de l'exÃ©cution de vos scripts.

On lance une exception Ã  l'aide du mot clÃ© **`throw`** et d'une expression.

On peut construire ses propres exception, en faisant un **`throw`** de String, Number, Boolean ou Object.

```js
function divideXByY(x, y) {
  if (y === 0) throw 'DivisionÂ by 0Â !Â ';
  return x / y;
}
divideXByY(5, 0); //Â UncaughtÂ DivisionÂ parÂ 0Â !
```

On peut aussi lancer des exceptions Ã  l'aide d'objets qui facilitent la gestion des exceptions : cela peut Ãªtre l'objet **`Error`** ou d'autres types d'erreurs prÃ©dÃ©finies par l'environnement JS (**`RangeError`**, **`SyntaxError`**...)

```js
function RegularDivideXByY(x, y) {
  if (y === 0) throw new RangeError('DivisionÂ byÂ 0Â !Â ');
  return x / y;
}
try {
  RegularDivideXByY(5, 0);
} catch (err) {
  console.log('RegularDivideXbyY():', err.name, ':', err.message);
  //Â RegularDivideXbyY()Â :Â RangeError:Â DivisionÂ byÂ 0Â !
}
```

Les deux propriÃ©tÃ©s intÃ©ressantes de "JS built-in error objects" sont : **`name`** & **`message`**.

Il est possible de crÃ©er vos propres classes d'erreur (en hÃ©ritant de la classe **`Error`**).

Si vous souhaitez plus de dÃ©tails sur les "JS built-in error objects", vous pouvez parcourir [la documentation MDN ici](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types) [[R.14]](/references/#r14).

## Intercepter une expression

On gÃ¨re l'apparition d'une exception au sein d'un bloc de code Ã  l'aide de **`try`** ... **`catch`** et Ã©ventuellement **`finally`** :

- **`try{...}`** : partie de code monitorÃ©e ;
- **`catch(err){...}`** : instructions Ã  exÃ©cuter en rÃ©ponses Ã  une exception ;
- **`finally{...}`** : code Ã  exÃ©cuter dans tous les cas aprÃ¨s le **`try`** ... **`catch`**, qu'il y ait eu une exception ou pas.

```js
let result;
try {
  result = RegularDivideXByY(5, 0);
} catch (err) {
  console.log('RegularDivideXbyY():', err.name, ':', err.message); //Â RegularDivideXbyY()Â :Â RangeError:Â DivisionÂ byÂ 0Â !
} finally {
  console.log(
    'RegularDivideXbyY()Â results:',
    result,
    "JSÂ Divion'sÂ result",
    5 / 0
  );
  //Â RegularDivideXbyY()Â results:Â undefinedÂ JSÂ Division'sÂ resultÂ Infinity
}
```

# <InternalPageTitle> Le destructuring assignment </InternalPageTitle>

Voici un exemple de **`destructing assignment`**, une faÃ§on trÃ¨s concise en JS de crÃ©er des variables Ã  partir de propriÃ©tÃ©s d'objets ou des valeurs d'arrays :

```js highlighting ="3"
// Here the variable and constants are defined
const decodedToken = jwt.verify(token, jwtSecret); // return the token payload
const { username, iat, exp } = decodedToken;
```

Imaginez ici que la valeur de **`decodedToken`** est : **`{ username: 'admin', iat: 1661251095, exp: 1747651095 }`**. 

Ce code **`const { username, iat, exp } = decodedToken;`** est l'Ã©quivalent de :
```js
const username = decodedToken.username;
const iat = decodedToken.iat;
const exp = decodedToken.exp;
```
Pour en savoir plus sur la puissance du **`destructuring assignement`**, vous pouvez consulter la [documentation de MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) [[R.64]](/references/#r64).
